CCS PCH C Compiler, Version 5.120, 4205               11-Aug-25 13:41

               Filename:   ..\ouput\main.lst

               ROM used:   6118 bytes (9%)
                           Largest free fragment is 59418
               RAM used:   1220 (31%) at main() level
                           1296 (33%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   15AC
.................... #import(file="..\ouput\eeprom_24LC512.o")
.................... //24LC512.c     eeprom driver
.................... //24LC512.c     eeprom driver
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #fuses INTRC_IO, NOWDT, NOLVP, NOPROTECT
.................... #use delay(clock=16M)
*
00012:  MOVLW  04
00014:  MOVWF  FEA
00016:  MOVLW  C6
00018:  MOVWF  FE9
0001A:  MOVF   FEF,W
0001C:  BZ    003A
0001E:  MOVLW  05
00020:  MOVWF  01
00022:  CLRF   00
00024:  DECFSZ 00,F
00026:  BRA    0024
00028:  DECFSZ 01,F
0002A:  BRA    0022
0002C:  MOVLW  2E
0002E:  MOVWF  00
00030:  DECFSZ 00,F
00032:  BRA    0030
00034:  BRA    0036
00036:  DECFSZ FEF,F
00038:  BRA    001E
0003A:  RETURN 0
.................... #use i2c(Master, SDA=PIN_C4, SCL=PIN_C3, FAST=100000)
0003C:  BCF    FC6.7
0003E:  BCF    F9E.3
00040:  MOVFF  4CB,FC9
00044:  MOVLW  02
00046:  BTFSC  FC6.7
00048:  BRA    0054
0004A:  BTFSC  FC7.2
0004C:  BRA    004A
0004E:  MOVLW  00
00050:  BTFSC  FC5.6
00052:  MOVLW  01
00054:  MOVWF  01
00056:  RETURN 0
*
0134A:  BCF    FC6.6
0134C:  BSF    FC5.3
0134E:  BTFSC  FC5.3
01350:  BRA    134E
01352:  BTFSC  00.0
01354:  BCF    FC5.5
01356:  BTFSS  00.0
01358:  BSF    FC5.5
0135A:  BSF    FC5.4
0135C:  BTFSC  FC5.4
0135E:  BRA    135C
01360:  MOVFF  FC9,01
01364:  GOTO   13A4 (RETURN)
.................... 
.................... #include "eeprom_24LC512.h"
.................... //24LC512.h     i2c eeprom driver
.................... #ifndef EEPROM_24LC512
.................... #define EEPROM_24LC512
.................... 
.................... #define EEPROM_ADDR_WRITE  0xA0
.................... #define EEPROM_ADDR_READ   0xA1
.................... 
.................... #define STATE_ADDR 0x0000
.................... 
.................... void eeprom_write_byte(BYTE data);
.................... BYTE eeprom_read_byte();
.................... 
.................... #endif
.................... 
.................... 
.................... void eeprom_write_byte(BYTE data) {
....................     //Writes byte to STATE_ADDR
....................     i2c_start();
*
013CC:  BSF    FC5.0
013CE:  BTFSC  FC5.0
013D0:  BRA    13CE
....................     i2c_write(EEPROM_ADDR_WRITE);
013D2:  MOVLW  A0
013D4:  MOVLB  4
013D6:  MOVWF  xCB
013D8:  MOVLB  0
013DA:  CALL   003C
....................     i2c_write(STATE_ADDR >> 8);     //upper bits
013DE:  MOVLB  4
013E0:  CLRF   xCB
013E2:  MOVLB  0
013E4:  CALL   003C
....................     i2c_write(STATE_ADDR & 0xFF);   //lower bits
013E8:  MOVLB  4
013EA:  CLRF   xCB
013EC:  MOVLB  0
013EE:  CALL   003C
....................     i2c_write(data);
013F2:  MOVFF  4C5,4CB
013F6:  CALL   003C
....................     i2c_stop();
013FA:  BSF    FC5.2
013FC:  BTFSC  FC5.2
013FE:  BRA    13FC
....................     delay_ms(5);
01400:  MOVLW  05
01402:  MOVLB  4
01404:  MOVWF  xC6
01406:  MOVLB  0
01408:  CALL   0012
0140C:  GOTO   1420 (RETURN)
.................... }
.................... 
.................... BYTE eeprom_read_byte() {
....................     //Reads byte from STATE_ADDR
....................     BYTE data;
....................     i2c_start();
*
01368:  BSF    FC5.0
0136A:  BTFSC  FC5.0
0136C:  BRA    136A
....................     i2c_write(EEPROM_ADDR_WRITE);
0136E:  MOVLW  A0
01370:  MOVLB  4
01372:  MOVWF  xCB
01374:  MOVLB  0
01376:  CALL   003C
....................     i2c_write(STATE_ADDR >> 8);     //upper bits
0137A:  MOVLB  4
0137C:  CLRF   xCB
0137E:  MOVLB  0
01380:  CALL   003C
....................     i2c_write(STATE_ADDR & 0xFF);   //lower bits
01384:  MOVLB  4
01386:  CLRF   xCB
01388:  MOVLB  0
0138A:  CALL   003C
....................     i2c_start();
0138E:  BSF    FC5.1
01390:  BTFSC  FC5.1
01392:  BRA    1390
....................     i2c_write(EEPROM_ADDR_READ);
01394:  MOVLW  A1
01396:  MOVLB  4
01398:  MOVWF  xCB
0139A:  MOVLB  0
0139C:  CALL   003C
....................     data = i2c_read(0);
013A0:  CLRF   00
013A2:  BRA    134A
013A4:  MOVFF  01,4C4
....................     i2c_stop();
013A8:  BSF    FC5.2
013AA:  BTFSC  FC5.2
013AC:  BRA    13AA
....................     return data;
013AE:  MOVLB  4
013B0:  MOVFF  4C4,01
013B4:  MOVLB  0
013B6:  GOTO   13BC (RETURN)
.................... }
.................... 
.................... //joystick.c
.................... //joystick.c
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "joystick.h"
.................... //joystick.h
.................... 
.................... #ifndef JOYSTICK_H
.................... #define JOYSTICK_H
.................... 
.................... unsigned int16 x;   //VRX on AN2
.................... unsigned int16 y;   //VRY on AN1
.................... int1 sw;            //Button on B0
.................... 
.................... void joystick_init();
.................... 
.................... int get_Joystick_X();
.................... int get_Joystick_Y();
.................... int1 get_Joystick_SW();
.................... 
.................... #endif
.................... 
.................... 
.................... #define VRX_PIN 2   //RA2
.................... #define VRY_PIN 1   //RA1
.................... #define SW_PIN  PIN_B0
.................... 
.................... void joystick_init(){
....................     setup_adc_ports(sAN1 | sAN2);
*
0029C:  MOVF   FC1,W
0029E:  ANDLW  F0
002A0:  MOVWF  FC1
002A2:  MOVLW  06
002A4:  MOVLB  F
002A6:  MOVWF  x38
002A8:  MOVLW  00
002AA:  MOVWF  x3C
002AC:  MOVWF  x39
002AE:  MOVWF  x3A
002B0:  MOVWF  x3B
....................     setup_adc(ADC_CLOCK_INTERNAL);
002B2:  MOVF   FC0,W
002B4:  ANDLW  C0
002B6:  IORLW  07
002B8:  MOVWF  FC0
002BA:  BCF    FC0.7
002BC:  BSF    FC2.0
.................... 
....................     port_b_pullups(TRUE);
002BE:  MOVLW  01
002C0:  MOVWF  F61
002C2:  BCF    FF1.7
....................     input(SW_PIN);
002C4:  BSF    F93.0
002C6:  MOVLB  0
002C8:  GOTO   02CE (RETURN)
.................... }
.................... 
.................... int get_Joystick_X(){
....................     set_adc_channel(VRX_PIN);
*
00A9A:  MOVLW  08
00A9C:  MOVWF  01
00A9E:  MOVF   FC2,W
00AA0:  ANDLW  83
00AA2:  IORWF  01,W
00AA4:  MOVWF  FC2
....................     delay_us(10);
00AA6:  MOVLW  0D
00AA8:  MOVWF  00
00AAA:  DECFSZ 00,F
00AAC:  BRA    0AAA
....................     return read_adc();
00AAE:  BSF    FC2.1
00AB0:  BTFSC  FC2.1
00AB2:  BRA    0AB0
00AB4:  MOVFF  FC4,01
00AB8:  GOTO   0AE0 (RETURN)
.................... }
.................... 
.................... int get_Joystick_Y(){
....................     set_adc_channel(VRY_PIN);
00ABC:  MOVLW  04
00ABE:  MOVWF  01
00AC0:  MOVF   FC2,W
00AC2:  ANDLW  83
00AC4:  IORWF  01,W
00AC6:  MOVWF  FC2
....................     delay_us(10);
00AC8:  MOVLW  0D
00ACA:  MOVWF  00
00ACC:  DECFSZ 00,F
00ACE:  BRA    0ACC
....................     return read_adc();
00AD0:  BSF    FC2.1
00AD2:  BTFSC  FC2.1
00AD4:  BRA    0AD2
00AD6:  MOVFF  FC4,01
00ADA:  GOTO   0AE6 (RETURN)
.................... }
.................... 
.................... int1 get_Joystick_SW(){
....................     return input(SW_PIN);
*
00694:  BSF    F93.0
00696:  MOVLW  00
00698:  BTFSC  F81.0
0069A:  MOVLW  01
0069C:  MOVWF  01
0069E:  RETURN 0
.................... }
.................... 
.................... 
.................... //sh1106.c
.................... //sh1106.c
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
*
00170:  MOVLB  5
00172:  MOVF   x0B,W
00174:  MULWF  x0D
00176:  MOVFF  FF3,01
0017A:  MOVFF  FF4,00
0017E:  MULWF  x0E
00180:  MOVF   FF3,W
00182:  ADDWF  00,F
00184:  MOVF   x0C,W
00186:  MULWF  x0D
00188:  MOVF   FF3,W
0018A:  ADDWFC 00,W
0018C:  MOVWF  02
0018E:  MOVLB  0
00190:  RETURN 0
.................... 
.................... #list
.................... 
.................... #fuses INTRC_IO, NOWDT, NOLVP, NOPROTECT
.................... #use delay(clock=16M)
.................... #use i2c(Master, SDA=PIN_C4, SCL=PIN_C3, FAST=100000)
.................... 
.................... #include "sh1106.h"
.................... //sh1106.h
.................... #ifndef SH1106_H
.................... #define SH1106_H
.................... 
.................... #define SH1106_ADDR 0x78
.................... #define WIDTH 128
.................... #define HEIGHT 64
.................... 
.................... extern BYTE buffer[8][128];
.................... 
.................... void sh1106_cmd(unsigned char cmd);
.................... void sh1106_data(unsigned char data);
.................... void sh1106_init();
.................... void sh1106_update_screen();
.................... void sh1106_draw_pixel(int x, int y, int color);
.................... void sh1106_clear_buffer();
.................... 
.................... #endif
.................... 
.................... 
.................... BYTE buffer[8][128];
.................... 
.................... void sh1106_cmd(unsigned char cmd) {
....................    i2c_start();
*
00058:  BSF    FC5.0
0005A:  BTFSC  FC5.0
0005C:  BRA    005A
....................    i2c_write(SH1106_ADDR);
0005E:  MOVLW  78
00060:  MOVLB  4
00062:  MOVWF  xCB
00064:  MOVLB  0
00066:  RCALL  003C
....................    i2c_write(0x00);
00068:  MOVLB  4
0006A:  CLRF   xCB
0006C:  MOVLB  0
0006E:  RCALL  003C
....................    i2c_write(cmd);
00070:  MOVFF  4CA,4CB
00074:  RCALL  003C
....................    i2c_stop();
00076:  BSF    FC5.2
00078:  BTFSC  FC5.2
0007A:  BRA    0078
0007C:  RETURN 0
.................... }
.................... 
.................... void sh1106_data(unsigned char data) {
....................    i2c_start();
*
001E8:  BSF    FC5.0
001EA:  BTFSC  FC5.0
001EC:  BRA    01EA
....................    i2c_write(SH1106_ADDR);
001EE:  MOVLW  78
001F0:  MOVLB  4
001F2:  MOVWF  xCB
001F4:  MOVLB  0
001F6:  RCALL  003C
....................    i2c_write(0x40);
001F8:  MOVLW  40
001FA:  MOVLB  4
001FC:  MOVWF  xCB
001FE:  MOVLB  0
00200:  RCALL  003C
....................    i2c_write(data);
00202:  MOVFF  4CA,4CB
00206:  RCALL  003C
....................    i2c_stop();
00208:  BSF    FC5.2
0020A:  BTFSC  FC5.2
0020C:  BRA    020A
0020E:  GOTO   027E (RETURN)
.................... }
.................... 
.................... void sh1106_init() {
....................    delay_ms(100);                       //wait for power
*
0007E:  MOVLW  64
00080:  MOVLB  4
00082:  MOVWF  xC6
00084:  MOVLB  0
00086:  RCALL  0012
.................... 
....................    sh1106_cmd(0xAE);                    //display off
00088:  MOVLW  AE
0008A:  MOVLB  4
0008C:  MOVWF  xCA
0008E:  MOVLB  0
00090:  RCALL  0058
....................    sh1106_cmd(0xD5); sh1106_cmd(0x80);  //set clock
00092:  MOVLW  D5
00094:  MOVLB  4
00096:  MOVWF  xCA
00098:  MOVLB  0
0009A:  RCALL  0058
0009C:  MOVLW  80
0009E:  MOVLB  4
000A0:  MOVWF  xCA
000A2:  MOVLB  0
000A4:  RCALL  0058
....................    sh1106_cmd(0xA8); sh1106_cmd(0x3F);  //multiplex 64
000A6:  MOVLW  A8
000A8:  MOVLB  4
000AA:  MOVWF  xCA
000AC:  MOVLB  0
000AE:  RCALL  0058
000B0:  MOVLW  3F
000B2:  MOVLB  4
000B4:  MOVWF  xCA
000B6:  MOVLB  0
000B8:  RCALL  0058
....................    sh1106_cmd(0xD3); sh1106_cmd(0x00);  //no offset
000BA:  MOVLW  D3
000BC:  MOVLB  4
000BE:  MOVWF  xCA
000C0:  MOVLB  0
000C2:  RCALL  0058
000C4:  MOVLB  4
000C6:  CLRF   xCA
000C8:  MOVLB  0
000CA:  RCALL  0058
....................    sh1106_cmd(0x40);                    //start line0
000CC:  MOVLW  40
000CE:  MOVLB  4
000D0:  MOVWF  xCA
000D2:  MOVLB  0
000D4:  RCALL  0058
.................... 
....................    sh1106_cmd(0xAD); sh1106_cmd(0x8B);  //charge pump
000D6:  MOVLW  AD
000D8:  MOVLB  4
000DA:  MOVWF  xCA
000DC:  MOVLB  0
000DE:  RCALL  0058
000E0:  MOVLW  8B
000E2:  MOVLB  4
000E4:  MOVWF  xCA
000E6:  MOVLB  0
000E8:  RCALL  0058
....................    sh1106_cmd(0xA1);                    //mirror x
000EA:  MOVLW  A1
000EC:  MOVLB  4
000EE:  MOVWF  xCA
000F0:  MOVLB  0
000F2:  RCALL  0058
....................    sh1106_cmd(0xC8);                    //mirror y
000F4:  MOVLW  C8
000F6:  MOVLB  4
000F8:  MOVWF  xCA
000FA:  MOVLB  0
000FC:  RCALL  0058
.................... 
....................    sh1106_cmd(0xDA); sh1106_cmd(0x12);  //com config
000FE:  MOVLW  DA
00100:  MOVLB  4
00102:  MOVWF  xCA
00104:  MOVLB  0
00106:  RCALL  0058
00108:  MOVLW  12
0010A:  MOVLB  4
0010C:  MOVWF  xCA
0010E:  MOVLB  0
00110:  RCALL  0058
....................    sh1106_cmd(0x81); sh1106_cmd(0xCF);  //contrast
00112:  MOVLW  81
00114:  MOVLB  4
00116:  MOVWF  xCA
00118:  MOVLB  0
0011A:  RCALL  0058
0011C:  MOVLW  CF
0011E:  MOVLB  4
00120:  MOVWF  xCA
00122:  MOVLB  0
00124:  RCALL  0058
....................    sh1106_cmd(0xD9); sh1106_cmd(0xF1);  //precharge
00126:  MOVLW  D9
00128:  MOVLB  4
0012A:  MOVWF  xCA
0012C:  MOVLB  0
0012E:  RCALL  0058
00130:  MOVLW  F1
00132:  MOVLB  4
00134:  MOVWF  xCA
00136:  MOVLB  0
00138:  RCALL  0058
....................    sh1106_cmd(0xDB); sh1106_cmd(0x40);  //vcom level
0013A:  MOVLW  DB
0013C:  MOVLB  4
0013E:  MOVWF  xCA
00140:  MOVLB  0
00142:  RCALL  0058
00144:  MOVLW  40
00146:  MOVLB  4
00148:  MOVWF  xCA
0014A:  MOVLB  0
0014C:  RCALL  0058
.................... 
....................    sh1106_cmd(0xA4);                   //use display ram
0014E:  MOVLW  A4
00150:  MOVLB  4
00152:  MOVWF  xCA
00154:  MOVLB  0
00156:  RCALL  0058
....................    sh1106_cmd(0xA6);                   //normal display
00158:  MOVLW  A6
0015A:  MOVLB  4
0015C:  MOVWF  xCA
0015E:  MOVLB  0
00160:  RCALL  0058
....................    sh1106_cmd(0xAF);                   //display on
00162:  MOVLW  AF
00164:  MOVLB  4
00166:  MOVWF  xCA
00168:  MOVLB  0
0016A:  RCALL  0058
0016C:  GOTO   0294 (RETURN)
.................... }
.................... 
.................... void sh1106_update_screen() {
....................    for (int page = 0; page < 8; page++) {
*
00212:  MOVLB  4
00214:  CLRF   xC7
00216:  MOVF   xC7,W
00218:  SUBLW  07
0021A:  BNC   0288
....................       sh1106_cmd(0xB0 + page);
0021C:  MOVLW  B0
0021E:  ADDWF  xC7,W
00220:  MOVWF  xC9
00222:  MOVWF  xCA
00224:  MOVLB  0
00226:  RCALL  0058
....................       sh1106_cmd(0x02);
00228:  MOVLW  02
0022A:  MOVLB  4
0022C:  MOVWF  xCA
0022E:  MOVLB  0
00230:  RCALL  0058
....................       sh1106_cmd(0x10);
00232:  MOVLW  10
00234:  MOVLB  4
00236:  MOVWF  xCA
00238:  MOVLB  0
0023A:  RCALL  0058
....................       for (int col = 0; col < 128; col++) {
0023C:  MOVLB  4
0023E:  CLRF   xC8
00240:  MOVF   xC8,W
00242:  SUBLW  7F
00244:  BNC   0284
....................          sh1106_data(buffer[page][col]);
00246:  MOVLB  5
00248:  CLRF   x0C
0024A:  MOVFF  4C7,50B
0024E:  CLRF   x0E
00250:  MOVLW  80
00252:  MOVWF  x0D
00254:  MOVLB  0
00256:  RCALL  0170
00258:  MOVFF  01,4C9
0025C:  MOVLB  4
0025E:  MOVF   xC8,W
00260:  ADDWF  01,W
00262:  MOVWF  01
00264:  MOVLW  00
00266:  ADDWFC 02,W
00268:  MOVWF  03
0026A:  MOVF   01,W
0026C:  ADDLW  09
0026E:  MOVWF  FE9
00270:  MOVLW  00
00272:  ADDWFC 03,W
00274:  MOVWF  FEA
00276:  MOVFF  FEF,4CA
0027A:  MOVLB  0
0027C:  BRA    01E8
0027E:  MOVLB  4
00280:  INCF   xC8,F
00282:  BRA    0240
....................       }
00284:  INCF   xC7,F
00286:  BRA    0216
....................    }
00288:  MOVLB  0
0028A:  GOTO   0290 (RETURN)
.................... }
.................... 
.................... void sh1106_draw_pixel(int x, int y, int color) {
....................    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return;
*
00324:  MOVLB  5
00326:  MOVF   x06,W
00328:  SUBLW  7F
0032A:  BC    0332
0032C:  BRA    0338
0032E:  BTFSC  00.0
00330:  BRA    0338
00332:  MOVF   x07,W
00334:  SUBLW  3F
00336:  BTFSS  FD8.0
00338:  BRA    03D0
.................... 
....................    int page = y / 8;
....................    BYTE mask = 1 << (y % 8);
0033A:  RRCF   x07,W
0033C:  MOVWF  x09
0033E:  RRCF   x09,F
00340:  RRCF   x09,F
00342:  MOVLW  1F
00344:  ANDWF  x09,F
00346:  MOVF   x07,W
00348:  ANDLW  07
0034A:  MOVWF  01
0034C:  MOVLW  01
0034E:  MOVWF  x0A
00350:  MOVF   01,F
00352:  BZ    035C
00354:  BCF    FD8.0
00356:  RLCF   x0A,F
00358:  DECFSZ 01,F
0035A:  BRA    0354
.................... 
....................    if (color)
0035C:  MOVF   x08,F
0035E:  BZ    039A
....................       buffer[page][x] |= mask;
00360:  CLRF   x0C
00362:  MOVFF  509,50B
00366:  CLRF   x0E
00368:  MOVLW  80
0036A:  MOVWF  x0D
0036C:  MOVLB  0
0036E:  RCALL  0170
00370:  MOVFF  02,50C
00374:  MOVFF  01,50B
00378:  MOVLB  5
0037A:  MOVF   x06,W
0037C:  ADDWF  01,W
0037E:  MOVWF  01
00380:  MOVLW  00
00382:  ADDWFC 02,W
00384:  MOVWF  03
00386:  MOVF   01,W
00388:  ADDLW  09
0038A:  MOVWF  FE9
0038C:  MOVLW  00
0038E:  ADDWFC 03,W
00390:  MOVWF  FEA
00392:  MOVF   FEF,W
00394:  IORWF  x0A,W
00396:  MOVWF  FEF
00398:  BRA    03D0
....................    else
....................       buffer[page][x] &= ~mask;
0039A:  CLRF   x0C
0039C:  MOVFF  509,50B
003A0:  CLRF   x0E
003A2:  MOVLW  80
003A4:  MOVWF  x0D
003A6:  MOVLB  0
003A8:  RCALL  0170
003AA:  MOVFF  01,50B
003AE:  MOVLB  5
003B0:  MOVF   x06,W
003B2:  ADDWF  01,W
003B4:  MOVWF  01
003B6:  MOVLW  00
003B8:  ADDWFC 02,W
003BA:  MOVWF  03
003BC:  MOVF   01,W
003BE:  ADDLW  09
003C0:  MOVWF  FE9
003C2:  MOVLW  00
003C4:  ADDWFC 03,W
003C6:  MOVWF  FEA
003C8:  MOVF   x0A,W
003CA:  XORLW  FF
003CC:  ANDWF  FEF,W
003CE:  MOVWF  FEF
003D0:  MOVLB  0
003D2:  RETURN 0
.................... }
.................... 
.................... void sh1106_clear_buffer() {
....................    for (int page = 0; page < 8; page++) {
*
00192:  MOVLB  4
00194:  CLRF   xC3
00196:  MOVF   xC3,W
00198:  SUBLW  07
0019A:  BNC   01DE
....................       for (int col = 0; col < 128; col++) {
0019C:  CLRF   xC4
0019E:  MOVF   xC4,W
001A0:  SUBLW  7F
001A2:  BNC   01DA
....................          buffer[page][col] = 0x00;
001A4:  MOVLB  5
001A6:  CLRF   x0C
001A8:  MOVFF  4C3,50B
001AC:  CLRF   x0E
001AE:  MOVLW  80
001B0:  MOVWF  x0D
001B2:  MOVLB  0
001B4:  RCALL  0170
001B6:  MOVFF  01,4C5
001BA:  MOVLB  4
001BC:  MOVF   xC4,W
001BE:  ADDWF  01,W
001C0:  MOVWF  01
001C2:  MOVLW  00
001C4:  ADDWFC 02,W
001C6:  MOVWF  03
001C8:  MOVF   01,W
001CA:  ADDLW  09
001CC:  MOVWF  FE9
001CE:  MOVLW  00
001D0:  ADDWFC 03,W
001D2:  MOVWF  FEA
001D4:  CLRF   FEF
001D6:  INCF   xC4,F
001D8:  BRA    019E
....................       }
001DA:  INCF   xC3,F
001DC:  BRA    0196
....................    }
001DE:  MOVLB  0
001E0:  GOTO   01E6 (RETURN)
.................... }
.................... 
.................... /*
.................... /*
....................     0.0: Joystick X/Y completely functional. Clean up the code a bit then make sure all button-related functions work
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "controller.h"
.................... #ifndef CONTROLLER_H
.................... #define CONTROLLER_H
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... //type contains p for player
.................... //              e for enemies
.................... //              b for bullet
.................... //this will help with detecting collisions later
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int vdir;   //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void controller_init();
.................... void controller_update(Vec2 *pos);
.................... void controller_update_button_only();
.................... 
.................... int1 is_button_pressed();
.................... int1 is_button_just_pressed();
.................... int1 is_button_just_released();
.................... 
.................... void controller_shoot(Player p, Bullet *b);
.................... 
.................... #endif
.................... 
.................... #include "../Drivers/joystick.h"
.................... //joystick.h
.................... 
.................... #ifndef JOYSTICK_H
.................... #define JOYSTICK_H
.................... 
.................... unsigned int16 x;   //VRX on AN2
.................... unsigned int16 y;   //VRY on AN1
.................... int1 sw;            //Button on B0
.................... 
.................... void joystick_init();
.................... 
.................... int get_Joystick_X();
.................... int get_Joystick_Y();
.................... int1 get_Joystick_SW();
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... 
.................... //type contains p for player
.................... //              e for enemies
.................... //              b for bullet
.................... //this will help with detecting collisions later
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int vdir;   //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... #define VER_BORDER 56
.................... #define HOR_BORDER 120
.................... 
.................... #define MOVE_SPEED      5
.................... #define ADC_MAX_VALUE   255
.................... 
.................... #define X_DEADZONE_MIN 120
.................... #define X_DEADZONE_MAX 135
.................... #define Y_DEADZONE_MIN 120
.................... #define Y_DEADZONE_MAX 135
.................... 
.................... static int1 button_pressed = 0;
.................... static int1 last_button_state = 0;
.................... static int1 just_pressed = 0;
.................... static int1 just_released = 0;
.................... 
.................... void controller_init(){
....................     joystick_init();
*
002CC:  BRA    029C
002CE:  GOTO   16D2 (RETURN)
.................... }
.................... 
.................... void controller_update(Vec2 *player_pos){
*
00ADE:  BRA    0A9A
00AE0:  MOVFF  01,4C9
00AE4:  BRA    0ABC
00AE6:  MOVFF  01,4CA
....................     int x = get_Joystick_X();  // 0–255
....................     int y = get_Joystick_Y();
.................... 
....................     // LEFT
....................     if (x < X_DEADZONE_MIN && player_pos->x > 0)
00AEA:  MOVLB  4
00AEC:  MOVF   xC9,W
00AEE:  SUBLW  77
00AF0:  BNC   0B0E
00AF2:  MOVFF  4C7,FE9
00AF6:  MOVFF  4C8,FEA
00AFA:  MOVF   FEF,F
00AFC:  BZ    0B0E
....................         player_pos->x -= MOVE_SPEED;
00AFE:  MOVFF  4C7,FE9
00B02:  MOVFF  4C8,FEA
00B06:  MOVLW  05
00B08:  SUBWF  FEF,W
00B0A:  MOVWF  FEF
00B0C:  BRA    0B30
....................     // RIGHT
....................     else if (x > X_DEADZONE_MAX && player_pos->x < HOR_BORDER)
00B0E:  MOVF   xC9,W
00B10:  SUBLW  87
00B12:  BC    0B30
00B14:  MOVFF  4C7,FE9
00B18:  MOVFF  4C8,FEA
00B1C:  MOVF   FEF,W
00B1E:  SUBLW  77
00B20:  BNC   0B30
....................         player_pos->x += MOVE_SPEED;
00B22:  MOVFF  4C7,FE9
00B26:  MOVFF  4C8,FEA
00B2A:  MOVLW  05
00B2C:  ADDWF  FEF,W
00B2E:  MOVWF  FEF
.................... 
....................     // DOWN
....................     if (y < Y_DEADZONE_MIN && player_pos->y < VER_BORDER)
00B30:  MOVF   xCA,W
00B32:  SUBLW  77
00B34:  BNC   0B5C
00B36:  MOVLW  01
00B38:  ADDWF  xC7,W
00B3A:  MOVWF  FE9
00B3C:  MOVLW  00
00B3E:  ADDWFC xC8,W
00B40:  MOVWF  FEA
00B42:  MOVF   FEF,W
00B44:  SUBLW  37
00B46:  BNC   0B5C
....................         player_pos->y += MOVE_SPEED;
00B48:  MOVLW  01
00B4A:  ADDWF  xC7,W
00B4C:  MOVWF  FE9
00B4E:  MOVLW  00
00B50:  ADDWFC xC8,W
00B52:  MOVWF  FEA
00B54:  MOVLW  05
00B56:  ADDWF  FEF,W
00B58:  MOVWF  FEF
00B5A:  BRA    0B84
....................     // UP
....................     else if (y > Y_DEADZONE_MAX && player_pos->y > 0)
00B5C:  MOVF   xCA,W
00B5E:  SUBLW  87
00B60:  BC    0B84
00B62:  MOVLW  01
00B64:  ADDWF  xC7,W
00B66:  MOVWF  FE9
00B68:  MOVLW  00
00B6A:  ADDWFC xC8,W
00B6C:  MOVWF  FEA
00B6E:  MOVF   FEF,F
00B70:  BZ    0B84
....................         player_pos->y -= MOVE_SPEED;
00B72:  MOVLW  01
00B74:  ADDWF  xC7,W
00B76:  MOVWF  FE9
00B78:  MOVLW  00
00B7A:  ADDWFC xC8,W
00B7C:  MOVWF  FEA
00B7E:  MOVLW  05
00B80:  SUBWF  FEF,W
00B82:  MOVWF  FEF
.................... 
....................     if (player_pos->x < 0)
00B84:  MOVFF  4C7,FE9
00B88:  MOVFF  4C8,FEA
....................         player_pos->x = 0;
....................     if (player_pos->x > HOR_BORDER)
00B8C:  MOVFF  4C7,FE9
00B90:  MOVFF  4C8,FEA
00B94:  MOVF   FEF,W
00B96:  SUBLW  78
00B98:  BC    0BA6
....................         player_pos->x = HOR_BORDER;
00B9A:  MOVFF  4C7,FE9
00B9E:  MOVFF  4C8,FEA
00BA2:  MOVLW  78
00BA4:  MOVWF  FEF
.................... 
....................     if (player_pos->y < 0)
00BA6:  MOVLW  01
00BA8:  ADDWF  xC7,W
00BAA:  MOVWF  FE9
00BAC:  MOVLW  00
00BAE:  ADDWFC xC8,W
00BB0:  MOVWF  FEA
....................         player_pos->y = 0;
....................     if (player_pos->y > VER_BORDER)
00BB2:  MOVLW  01
00BB4:  ADDWF  xC7,W
00BB6:  MOVWF  FE9
00BB8:  MOVLW  00
00BBA:  ADDWFC xC8,W
00BBC:  MOVWF  FEA
00BBE:  MOVF   FEF,W
00BC0:  SUBLW  38
00BC2:  BC    0BD4
....................         player_pos->y = VER_BORDER;
00BC4:  MOVLW  01
00BC6:  ADDWF  xC7,W
00BC8:  MOVWF  FE9
00BCA:  MOVLW  00
00BCC:  ADDWFC xC8,W
00BCE:  MOVWF  FEA
00BD0:  MOVLW  38
00BD2:  MOVWF  FEF
.................... 
....................     
....................     //button handling
....................     int1 sw = get_Joystick_SW();
00BD4:  MOVLB  0
00BD6:  RCALL  0694
00BD8:  MOVLB  4
00BDA:  BCF    xCB.0
00BDC:  BTFSC  01.0
00BDE:  BSF    xCB.0
....................     button_pressed = !sw;  // active-low
00BE0:  BCF    08.2
00BE2:  BTFSS  xCB.0
00BE4:  BSF    08.2
....................     just_pressed = (button_pressed && !last_button_state);
00BE6:  BCF    08.4
00BE8:  BTFSS  08.2
00BEA:  BRA    0BF2
00BEC:  BTFSC  08.3
00BEE:  BRA    0BF2
00BF0:  BSF    08.4
....................     just_released = (!button_pressed && last_button_state);
00BF2:  BCF    08.5
00BF4:  BTFSC  08.2
00BF6:  BRA    0BFE
00BF8:  BTFSS  08.3
00BFA:  BRA    0BFE
00BFC:  BSF    08.5
....................     last_button_state = button_pressed;
00BFE:  BCF    08.3
00C00:  BTFSC  08.2
00C02:  BSF    08.3
00C04:  MOVLB  0
00C06:  GOTO   0CE4 (RETURN)
.................... }
.................... 
.................... void controller_update_button_only(){
*
006A0:  RCALL  0694
006A2:  MOVLB  4
006A4:  BCF    xC3.0
006A6:  BTFSC  01.0
006A8:  BSF    xC3.0
....................     int1 sw = get_Joystick_SW();
....................     button_pressed = !sw;  // active-low
006AA:  BCF    08.2
006AC:  BTFSS  xC3.0
006AE:  BSF    08.2
....................     just_pressed = (button_pressed && !last_button_state);
006B0:  BCF    08.4
006B2:  BTFSS  08.2
006B4:  BRA    06BC
006B6:  BTFSC  08.3
006B8:  BRA    06BC
006BA:  BSF    08.4
....................     just_released = (!button_pressed && last_button_state);
006BC:  BCF    08.5
006BE:  BTFSC  08.2
006C0:  BRA    06C8
006C2:  BTFSS  08.3
006C4:  BRA    06C8
006C6:  BSF    08.5
....................     last_button_state = button_pressed;
006C8:  BCF    08.3
006CA:  BTFSC  08.2
006CC:  BSF    08.3
006CE:  MOVLB  0
006D0:  RETURN 0
.................... }
.................... 
.................... int1 is_button_pressed(){
....................     return button_pressed;
*
00C0A:  MOVLW  00
00C0C:  BTFSC  08.2
00C0E:  MOVLW  01
00C10:  MOVWF  01
00C12:  GOTO   0C18 (RETURN)
.................... }
.................... 
.................... int1 is_button_just_pressed(){
....................     return just_pressed;
*
006D2:  MOVLW  00
006D4:  BTFSC  08.4
006D6:  MOVLW  01
006D8:  MOVWF  01
006DA:  RETURN 0
.................... }
.................... 
.................... int1 is_button_just_released(){
....................     return just_released;
.................... }
.................... 
.................... void controller_shoot(Player p, Bullet *b){
....................     if (is_button_pressed() && !b->is_active){
*
00C16:  BRA    0C0A
00C18:  MOVF   01,F
00C1A:  BZ    0C64
00C1C:  MOVLW  03
00C1E:  MOVLB  4
00C20:  ADDWF  xCA,W
00C22:  MOVWF  FE9
00C24:  MOVLW  00
00C26:  ADDWFC xCB,W
00C28:  MOVWF  FEA
00C2A:  MOVF   FEF,F
00C2C:  BTFSC  FD8.2
00C2E:  BRA    0C34
00C30:  MOVLB  0
00C32:  BRA    0C64
....................             b->is_active = 1;
00C34:  MOVLW  03
00C36:  ADDWF  xCA,W
00C38:  MOVWF  FE9
00C3A:  MOVLW  00
00C3C:  ADDWFC xCB,W
00C3E:  MOVWF  FEA
00C40:  MOVLW  01
00C42:  MOVWF  FEF
....................             b->pos.x = p.pos.x - 8;
00C44:  ADDWF  xCA,W
00C46:  MOVWF  FE9
00C48:  MOVLW  00
00C4A:  ADDWFC xCB,W
00C4C:  MOVWF  FEA
00C4E:  MOVLW  08
00C50:  SUBWF  xC8,W
00C52:  MOVWF  FEF
....................             b->pos.y = p.pos.y;
00C54:  MOVLW  02
00C56:  ADDWF  xCA,W
00C58:  MOVWF  FE9
00C5A:  MOVLW  00
00C5C:  ADDWFC xCB,W
00C5E:  MOVWF  FEA
00C60:  MOVFF  4C9,FEF
00C64:  MOVLB  0
....................         }
00C66:  GOTO   0CFE (RETURN)
.................... }
.................... 
.................... /*By removing the update from the second half of functions, you can draw in buffer and then later push to the screen and make
.................... /*By removing the update from the second half of functions, you can draw in buffer and then later push to the screen and make
....................   rendering enemies way more efficient that way.
.................... 
....................   use an enemy move interval to move enmies every x frames
....................   then draw player/bullet to buffer
....................   then push to screen all at once
.................... 
....................   1.0: now enemies are rendered together - need to implement move intervals
.................... 
....................   NB: screen top left is 0,0 while bottom right is (128, 64)
.................... */
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
*
0084E:  MOVLB  4
00850:  MOVF   xFC,W
00852:  CLRF   01
00854:  SUBWF  xFB,W
00856:  BC    085E
00858:  MOVFF  4FB,00
0085C:  BRA    0876
0085E:  CLRF   00
00860:  MOVLW  08
00862:  MOVWF  xFD
00864:  RLCF   xFB,F
00866:  RLCF   00,F
00868:  MOVF   xFC,W
0086A:  SUBWF  00,W
0086C:  BTFSC  FD8.0
0086E:  MOVWF  00
00870:  RLCF   01,F
00872:  DECFSZ xFD,F
00874:  BRA    0864
00876:  MOVLB  0
00878:  RETURN 0
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "display.h"
.................... #ifndef DISPLAY_H
.................... #define DISPLAY_H
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... //type contains p for player
.................... //              e for enemies
.................... //              b for bullet
.................... //this will help with detecting collisions later
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int vdir;   //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void display_init();
.................... void display_clear();
.................... void display_update();
.................... 
.................... void display_gameover_screen(int score, int high_score);
.................... void display_start_screen();
.................... 
.................... void display_draw_digit(Vec2 pos, int digit);
.................... void display_draw_number(Vec2 pos, int number);
.................... void display_count_0_to_100();
.................... 
.................... void display_draw_letter(Vec2 pos, char c);
.................... void display_draw_word(Vec2 pos, int8 word[], int length);
.................... 
.................... void display_draw_player(Vec2 pos);
.................... void display_draw_enemy(Vec2 pos);
.................... void display_draw_bullet(Vec2 pos);
.................... void display_draw_score(int score);
.................... 
.................... void display_clear_score();
.................... 
.................... void display_clear_entity(Vec2 pos, int h, int w);
.................... void display_draw_entity(Vec2 pos, int8 sprite[], int h, int w);
.................... 
.................... Vec2 display_move_player(Vec2 pos);
.................... Enemy display_move_enemy(Enemy enemy);
.................... Bullet display_move_bullet(Bullet bullet);
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/font.h"
.................... #ifndef FONT_H
.................... #define FONT_H
.................... 
.................... #define LETTER_ARR_SIZE     17
.................... 
.................... int8 digit_font_3x5[10][3] = {
....................     {0x1F, 0x11, 0x1F}, // 0
....................     {0x00, 0x1F, 0x00}, // 1
....................     {0x1D, 0x15, 0x17}, // 2
....................     {0x15, 0x15, 0x1F}, // 3
....................     {0x07, 0x04, 0x1F}, // 4
....................     {0x17, 0x15, 0x1D}, // 5
....................     {0x1F, 0x15, 0x1D}, // 6
....................     {0x01, 0x01, 0x1F}, // 7
....................     {0x1F, 0x15, 0x1F}, // 8
....................     {0x17, 0x15, 0x1F}  // 9
.................... };
.................... 
.................... char letter_index_3x5[] = {
....................     'a', 'e', 'g', 'h', 'm', 'o', 'r', 's', 't', 'v', 'p', 'c', 'l', 'i', 'k', 'n', 'd'
.................... };
.................... 
.................... int8 letter_font_3x5[17][3] = {
....................     {0x1E, 0x05, 0x1F}, // a
....................     {0x1F, 0x15, 0x15}, // e
....................     {0x0E, 0x11, 0x1D}, // g
....................     {0x1F, 0x04, 0x1F}, // h
....................     {0x1F, 0x06, 0x1F}, // m
....................     {0x0E, 0x11, 0x0E}, // o
....................     {0x1F, 0x05, 0x1A}, // r
....................     {0x12, 0x15, 0x09}, // s
....................     {0x01, 0x1F, 0x01}, // t
....................     {0x07, 0x18, 0x07}, // v
....................     {0x1F, 0x05, 0x02}, // p
....................     {0x0E, 0x11, 0x11}, // c
....................     {0x1F, 0x10, 0x10}, // l
....................     {0x00, 0x1D, 0x00}, // i
....................     {0x1F, 0x04, 0x1B}, // k
....................     {0x1F, 0x01, 0x1E}, // n
....................     {0x1F, 0x11, 0x0E}  // d
.................... };
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/sprites.h"
.................... #ifndef SPRITES_H
.................... #define SPRITES_H
.................... 
.................... #define SPRITE_SIZE 8 
.................... 
.................... extern  int8 PLAYER_SPRITE[8];
.................... extern  int8 ENEMY_SPRITE[8];
.................... extern  int8 BULLET_SPRITE[8];
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Drivers/sh1106.h"
.................... //sh1106.h
.................... #ifndef SH1106_H
.................... #define SH1106_H
.................... 
.................... #define SH1106_ADDR 0x78
.................... #define WIDTH 128
.................... #define HEIGHT 64
.................... 
.................... extern BYTE buffer[8][128];
.................... 
.................... void sh1106_cmd(unsigned char cmd);
.................... void sh1106_data(unsigned char data);
.................... void sh1106_init();
.................... void sh1106_update_screen();
.................... void sh1106_draw_pixel(int x, int y, int color);
.................... void sh1106_clear_buffer();
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... 
.................... //type contains p for player
.................... //              e for enemies
.................... //              b for bullet
.................... //this will help with detecting collisions later
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int vdir;   //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void display_init(){
....................     //wrapper for oled driver to initialize
....................     sh1106_init();
*
00292:  BRA    007E
....................     display_clear();
00294:  RCALL  01E4
....................     display_update();
00296:  RCALL  028E
00298:  GOTO   16CE (RETURN)
.................... }
.................... 
.................... void display_clear(){
....................     //wrapper for oled driver clear
....................     sh1106_clear_buffer();
*
001E4:  BRA    0192
001E6:  RETURN 0
.................... }
.................... 
.................... void display_update(){
....................     //wrapper for oled driver update
....................     sh1106_update_screen();
*
0028E:  BRA    0212
00290:  RETURN 0
.................... }
.................... 
.................... void display_draw_digit(Vec2 pos, int digit){
....................     if (digit < 0 || digit > 9) return;
*
007C0:  MOVLB  4
007C2:  MOVF   xFD,W
007C4:  SUBLW  09
007C6:  BTFSS  FD8.0
007C8:  BRA    084A
.................... 
....................     for (int col = 0; col < 3; col++){
007CA:  CLRF   xFE
007CC:  MOVF   xFE,W
007CE:  SUBLW  02
007D0:  BNC   084A
....................         for (int row = 0; row < 5; row++){
007D2:  CLRF   xFF
007D4:  MOVF   xFF,W
007D6:  SUBLW  04
007D8:  BNC   0846
....................             int pixel = (digit_font_3x5[digit][col] >> row) & 1;
007DA:  MOVF   xFD,W
007DC:  MULLW  03
007DE:  MOVF   FF3,W
007E0:  MOVLB  5
007E2:  CLRF   x02
007E4:  MOVWF  x01
007E6:  CLRF   03
007E8:  MOVLB  4
007EA:  MOVF   xFE,W
007EC:  MOVLB  5
007EE:  ADDWF  x01,W
007F0:  MOVWF  01
007F2:  MOVF   x02,W
007F4:  ADDWFC 03,F
007F6:  MOVF   01,W
007F8:  ADDLW  0D
007FA:  MOVWF  FE9
007FC:  MOVLW  04
007FE:  ADDWFC 03,W
00800:  MOVWF  FEA
00802:  MOVFF  FEF,00
00806:  MOVLB  4
00808:  MOVF   xFF,W
0080A:  MOVWF  01
0080C:  BZ    0816
0080E:  BCF    FD8.0
00810:  RRCF   00,F
00812:  DECFSZ 01,F
00814:  BRA    080E
00816:  MOVF   00,W
00818:  ANDLW  01
0081A:  MOVLB  5
0081C:  MOVWF  x00
....................             sh1106_draw_pixel(pos.x + col, pos.y + row, pixel);
0081E:  MOVLB  4
00820:  MOVF   xFE,W
00822:  ADDWF  xFB,W
00824:  MOVLB  5
00826:  MOVWF  x01
00828:  MOVLB  4
0082A:  MOVF   xFF,W
0082C:  ADDWF  xFC,W
0082E:  MOVLB  5
00830:  MOVWF  x02
00832:  MOVFF  501,506
00836:  MOVWF  x07
00838:  MOVFF  500,508
0083C:  MOVLB  0
0083E:  RCALL  0324
00840:  MOVLB  4
00842:  INCF   xFF,F
00844:  BRA    07D4
....................         }
00846:  INCF   xFE,F
00848:  BRA    07CC
....................     }
0084A:  MOVLB  0
0084C:  RETURN 0
.................... }
.................... 
.................... void display_draw_number(Vec2 pos, int number) {
....................     if (number < 0 || number > 100) return;
*
0087A:  MOVLB  4
0087C:  MOVF   xF0,W
0087E:  SUBLW  64
00880:  BTFSS  FD8.0
00882:  BRA    0964
.................... 
....................     if (number == 100) {
00884:  MOVF   xF0,W
00886:  SUBLW  64
00888:  BNZ   08D2
....................         Vec2 pos1, pos2;
.................... 
....................         display_draw_digit(pos, 1);
0088A:  MOVFF  4EF,4FC
0088E:  MOVFF  4EE,4FB
00892:  MOVLW  01
00894:  MOVWF  xFD
00896:  MOVLB  0
00898:  RCALL  07C0
.................... 
....................         pos1.x = pos.x + 4;
0089A:  MOVLW  04
0089C:  MOVLB  4
0089E:  ADDWF  xEE,W
008A0:  MOVWF  xF1
....................         pos1.y = pos.y;
008A2:  MOVFF  4EF,4F2
....................         display_draw_digit(pos1, 0);
008A6:  MOVFF  4F2,4FC
008AA:  MOVFF  4F1,4FB
008AE:  CLRF   xFD
008B0:  MOVLB  0
008B2:  RCALL  07C0
.................... 
....................         pos2.x = pos.x + 8;
008B4:  MOVLW  08
008B6:  MOVLB  4
008B8:  ADDWF  xEE,W
008BA:  MOVWF  xF3
....................         pos2.y = pos.y;
008BC:  MOVFF  4EF,4F4
....................         display_draw_digit(pos2, 0);
008C0:  MOVFF  4F4,4FC
008C4:  MOVFF  4F3,4FB
008C8:  CLRF   xFD
008CA:  MOVLB  0
008CC:  RCALL  07C0
.................... 
....................         return;
008CE:  MOVLB  4
008D0:  BRA    0964
....................     }
.................... 
....................     int tens = number / 10;
....................     int ones = number % 10;
008D2:  MOVFF  4F0,4FB
008D6:  MOVLW  0A
008D8:  MOVWF  xFC
008DA:  MOVLB  0
008DC:  RCALL  084E
008DE:  MOVFF  01,4F5
008E2:  MOVFF  4F0,4FB
008E6:  MOVLW  0A
008E8:  MOVLB  4
008EA:  MOVWF  xFC
008EC:  MOVLB  0
008EE:  RCALL  084E
008F0:  MOVFF  00,4F6
.................... 
....................     if (tens > 0) {
008F4:  MOVLB  4
008F6:  MOVF   xF5,F
008F8:  BZ    090E
....................         display_draw_digit(pos, tens);
008FA:  MOVFF  4EF,4FC
008FE:  MOVFF  4EE,4FB
00902:  MOVFF  4F5,4FD
00906:  MOVLB  0
00908:  RCALL  07C0
....................     } else {
0090A:  BRA    0946
0090C:  MOVLB  4
....................         //clear tens digit area if number < 10
....................         for (int col = 0; col < 3; col++) {
0090E:  CLRF   xF7
00910:  MOVF   xF7,W
00912:  SUBLW  02
00914:  BNC   0944
....................             for (int row = 0; row < 5; row++) {
00916:  CLRF   xF8
00918:  MOVF   xF8,W
0091A:  SUBLW  04
0091C:  BNC   0940
....................                 sh1106_draw_pixel(pos.x + col, pos.y + row, 0);
0091E:  MOVF   xF7,W
00920:  ADDWF  xEE,W
00922:  MOVWF  xFB
00924:  MOVF   xF8,W
00926:  ADDWF  xEF,W
00928:  MOVWF  xFC
0092A:  MOVFF  4FB,506
0092E:  MOVFF  FE8,507
00932:  MOVLB  5
00934:  CLRF   x08
00936:  MOVLB  0
00938:  RCALL  0324
0093A:  MOVLB  4
0093C:  INCF   xF8,F
0093E:  BRA    0918
....................             }
00940:  INCF   xF7,F
00942:  BRA    0910
00944:  MOVLB  0
....................         }
....................     }
.................... 
....................     Vec2 ones_pos;
....................     ones_pos.x = pos.x + 4;
00946:  MOVLW  04
00948:  MOVLB  4
0094A:  ADDWF  xEE,W
0094C:  MOVWF  xF9
....................     ones_pos.y = pos.y;
0094E:  MOVFF  4EF,4FA
....................     display_draw_digit(ones_pos, ones);
00952:  MOVFF  4FA,4FC
00956:  MOVFF  4F9,4FB
0095A:  MOVFF  4F6,4FD
0095E:  MOVLB  0
00960:  RCALL  07C0
00962:  MOVLB  4
00964:  MOVLB  0
00966:  RETURN 0
.................... }
.................... 
.................... //only for testing if all digits are working
.................... void display_count_0_to_100() {
....................     Vec2 pos = {0, 0};
.................... 
....................     for (int i = 0; i <= 100; i++) {
....................         display_clear();           // Clear screen buffer
....................         display_draw_number(pos, i);
....................         display_update();          // Push buffer to screen
....................         delay_ms(200);             // Wait 200ms between numbers
....................     }
.................... }
.................... 
.................... void display_draw_letter(Vec2 pos, char c){
....................     //displays letter at pos.x, pos.y
....................     for (int i = 0; i < LETTER_ARR_SIZE; i++){
*
003D4:  MOVLB  5
003D6:  CLRF   x00
003D8:  MOVF   x00,W
003DA:  SUBLW  10
003DC:  BNC   0476
....................         if (letter_index_3x5[i] == c){
003DE:  CLRF   03
003E0:  MOVF   x00,W
003E2:  ADDLW  2B
003E4:  MOVWF  FE9
003E6:  MOVLW  04
003E8:  ADDWFC 03,W
003EA:  MOVWF  FEA
003EC:  MOVLB  4
003EE:  MOVF   xFF,W
003F0:  SUBWF  FEF,W
003F2:  BNZ   0470
....................             for (int col = 0; col < 3; col++){
003F4:  MOVLB  5
003F6:  CLRF   x01
003F8:  MOVF   x01,W
003FA:  SUBLW  02
003FC:  BNC   046C
....................                 for (int row = 0; row < 5; row++){
003FE:  CLRF   x02
00400:  MOVF   x02,W
00402:  SUBLW  04
00404:  BNC   0468
....................                     int pixel = (letter_font_3x5[i][col] >> row) & 1;
00406:  MOVF   x00,W
00408:  MULLW  03
0040A:  MOVF   FF3,W
0040C:  CLRF   x05
0040E:  MOVWF  x04
00410:  CLRF   03
00412:  MOVF   x01,W
00414:  ADDWF  x04,W
00416:  MOVWF  01
00418:  MOVF   x05,W
0041A:  ADDWFC 03,F
0041C:  MOVF   01,W
0041E:  ADDLW  3C
00420:  MOVWF  FE9
00422:  MOVLW  04
00424:  ADDWFC 03,W
00426:  MOVWF  FEA
00428:  MOVFF  FEF,00
0042C:  MOVF   x02,W
0042E:  MOVWF  01
00430:  BZ    043A
00432:  BCF    FD8.0
00434:  RRCF   00,F
00436:  DECFSZ 01,F
00438:  BRA    0432
0043A:  MOVF   00,W
0043C:  ANDLW  01
0043E:  MOVWF  x03
....................                     sh1106_draw_pixel(pos.x + col, pos.y + row, pixel);
00440:  MOVF   x01,W
00442:  MOVLB  4
00444:  ADDWF  xFD,W
00446:  MOVLB  5
00448:  MOVWF  x04
0044A:  MOVF   x02,W
0044C:  MOVLB  4
0044E:  ADDWF  xFE,W
00450:  MOVLB  5
00452:  MOVWF  x05
00454:  MOVFF  504,506
00458:  MOVWF  x07
0045A:  MOVFF  503,508
0045E:  MOVLB  0
00460:  RCALL  0324
00462:  MOVLB  5
00464:  INCF   x02,F
00466:  BRA    0400
....................                 }
00468:  INCF   x01,F
0046A:  BRA    03F8
....................             }
....................             return;
0046C:  BRA    0476
0046E:  MOVLB  4
....................         }
00470:  MOVLB  5
00472:  INCF   x00,F
00474:  BRA    03D8
....................     }
00476:  MOVLB  0
00478:  GOTO   04A2 (RETURN)
.................... }
.................... 
.................... void display_draw_word(Vec2 pos, int8 word[], int length){
....................     for (int i = 0; i < length; i++){
0047C:  MOVLB  4
0047E:  CLRF   xFB
00480:  MOVF   xFA,W
00482:  SUBWF  xFB,W
00484:  BC    04AC
....................         display_draw_letter(pos, word[i]);
00486:  MOVF   xFB,W
00488:  ADDWF  xF8,W
0048A:  MOVWF  FE9
0048C:  MOVLW  00
0048E:  ADDWFC xF9,W
00490:  MOVWF  FEA
00492:  MOVFF  FEF,4FF
00496:  MOVFF  4F7,4FE
0049A:  MOVFF  4F6,4FD
0049E:  MOVLB  0
004A0:  BRA    03D4
....................         pos.x += 4; // move right to draw next letter (3 width + 1 space)
004A2:  MOVLW  04
004A4:  MOVLB  4
004A6:  ADDWF  xF6,F
004A8:  INCF   xFB,F
004AA:  BRA    0480
....................     }
004AC:  MOVLB  0
004AE:  RETURN 0
.................... }
.................... 
.................... void display_draw_entity(Vec2 pos, int8 *sprite_data, int h, int w){
....................     //renders an entity on screen
....................     int i, j;
....................     for (i = 0; i < h; i++){
004B0:  MOVLB  4
004B2:  CLRF   xFE
004B4:  MOVF   xFC,W
004B6:  SUBWF  xFE,W
004B8:  BC    0514
....................         for (j = 0; j < w; j++){
004BA:  CLRF   xFF
004BC:  MOVF   xFD,W
004BE:  SUBWF  xFF,W
004C0:  BC    0510
....................             int pixel = (sprite_data[i] >> j) & 1;
004C2:  MOVF   xFE,W
004C4:  ADDWF  xFA,W
004C6:  MOVWF  FE9
004C8:  MOVLW  00
004CA:  ADDWFC xFB,W
004CC:  MOVWF  FEA
004CE:  MOVFF  FEF,00
004D2:  MOVF   xFF,W
004D4:  MOVWF  01
004D6:  BZ    04E0
004D8:  BCF    FD8.0
004DA:  RRCF   00,F
004DC:  DECFSZ 01,F
004DE:  BRA    04D8
004E0:  MOVF   00,W
004E2:  ANDLW  01
004E4:  MOVLB  5
004E6:  MOVWF  x00
....................             sh1106_draw_pixel(pos.x + j, pos.y + i, pixel);
004E8:  MOVLB  4
004EA:  MOVF   xFF,W
004EC:  ADDWF  xF8,W
004EE:  MOVLB  5
004F0:  MOVWF  x01
004F2:  MOVLB  4
004F4:  MOVF   xFE,W
004F6:  ADDWF  xF9,W
004F8:  MOVLB  5
004FA:  MOVWF  x02
004FC:  MOVFF  501,506
00500:  MOVWF  x07
00502:  MOVFF  500,508
00506:  MOVLB  0
00508:  RCALL  0324
0050A:  MOVLB  4
0050C:  INCF   xFF,F
0050E:  BRA    04BC
....................         }
00510:  INCF   xFE,F
00512:  BRA    04B4
....................     }
00514:  MOVLB  0
00516:  RETURN 0
.................... }
.................... 
.................... void display_clear_entity(Vec2 pos, int h, int w){
....................     //clears an entity from the screen
....................     int i, j;
....................     for (i = 0; i < h; i++){
*
00A5E:  MOVLB  4
00A60:  CLRF   xE4
00A62:  MOVF   xE2,W
00A64:  SUBWF  xE4,W
00A66:  BC    0A96
....................         for (j = 0; j < w; j++){
00A68:  CLRF   xE5
00A6A:  MOVF   xE3,W
00A6C:  SUBWF  xE5,W
00A6E:  BC    0A92
....................             sh1106_draw_pixel(pos.x + j, pos.y + i, 0);
00A70:  MOVF   xE5,W
00A72:  ADDWF  xE0,W
00A74:  MOVWF  xE6
00A76:  MOVF   xE4,W
00A78:  ADDWF  xE1,W
00A7A:  MOVWF  xE7
00A7C:  MOVFF  4E6,506
00A80:  MOVFF  FE8,507
00A84:  MOVLB  5
00A86:  CLRF   x08
00A88:  MOVLB  0
00A8A:  RCALL  0324
00A8C:  MOVLB  4
00A8E:  INCF   xE5,F
00A90:  BRA    0A6A
....................         }
00A92:  INCF   xE4,F
00A94:  BRA    0A62
....................     }
00A96:  MOVLB  0
00A98:  RETURN 0
.................... }
.................... 
.................... void display_draw_player(Vec2 pos){
....................     //renders player at pos.x and pos.y
....................     display_draw_entity(pos, PLAYER_SPRITE, 8, 8);
*
00518:  MOVFF  4F7,4F9
0051C:  MOVFF  4F6,4F8
00520:  MOVLW  04
00522:  MOVLB  4
00524:  MOVWF  xFB
00526:  MOVLW  6F
00528:  MOVWF  xFA
0052A:  MOVLW  08
0052C:  MOVWF  xFC
0052E:  MOVWF  xFD
00530:  MOVLB  0
00532:  RCALL  04B0
00534:  RETURN 0
.................... }
.................... 
.................... void display_draw_enemy(Vec2 pos){
....................     //renders enemy at pos.x and pso.y
....................     display_draw_entity(pos, ENEMY_SPRITE, 8, 8);
*
00554:  MOVFF  4F7,4F9
00558:  MOVFF  4F6,4F8
0055C:  MOVLW  04
0055E:  MOVLB  4
00560:  MOVWF  xFB
00562:  MOVLW  77
00564:  MOVWF  xFA
00566:  MOVLW  08
00568:  MOVWF  xFC
0056A:  MOVWF  xFD
0056C:  MOVLB  0
0056E:  RCALL  04B0
00570:  RETURN 0
.................... }
.................... 
.................... void display_draw_bullet(Vec2 pos){
....................     //renders bullet at pos.x and pso.y
....................     display_draw_entity(pos, BULLET_SPRITE, 8, 8);
*
00536:  MOVFF  4F7,4F9
0053A:  MOVFF  4F6,4F8
0053E:  MOVLW  04
00540:  MOVLB  4
00542:  MOVWF  xFB
00544:  MOVLW  7F
00546:  MOVWF  xFA
00548:  MOVLW  08
0054A:  MOVWF  xFC
0054C:  MOVWF  xFD
0054E:  MOVLB  0
00550:  RCALL  04B0
00552:  RETURN 0
.................... }
.................... 
.................... void display_draw_score(int score){
....................     Vec2 pos = {112, 0};
*
00968:  MOVLW  70
0096A:  MOVLB  4
0096C:  MOVWF  xC9
0096E:  CLRF   xCA
....................     display_draw_number(pos, score);
00970:  MOVFF  4CA,4EF
00974:  MOVFF  4C9,4EE
00978:  MOVFF  4C8,4F0
0097C:  MOVLB  0
0097E:  RCALL  087A
00980:  RETURN 0
.................... }
.................... 
.................... void display_clear_score(){
....................     Vec2 pos = {112, 0};
*
01254:  MOVLW  70
01256:  MOVLB  4
01258:  MOVWF  xC8
0125A:  CLRF   xC9
....................     display_clear_entity(pos, 11, 5);
0125C:  MOVFF  4C9,4E1
01260:  MOVFF  4C8,4E0
01264:  MOVLW  0B
01266:  MOVWF  xE2
01268:  MOVLW  05
0126A:  MOVWF  xE3
0126C:  MOVLB  0
0126E:  CALL   0A5E
01272:  GOTO   12AC (RETURN)
.................... }
.................... 
.................... Vec2 display_move_player(Vec2 pos){
*
00C6A:  MOVFF  4C8,4CA
00C6E:  MOVFF  4C7,4C9
....................     //moves the player
....................     Vec2 last_pos = pos;
.................... 
....................     display_clear_entity(last_pos, 8, 8);
00C72:  MOVFF  4CA,4E1
00C76:  MOVFF  4C9,4E0
00C7A:  MOVLW  08
00C7C:  MOVLB  4
00C7E:  MOVWF  xE2
00C80:  MOVWF  xE3
00C82:  MOVLB  0
00C84:  RCALL  0A5E
.................... 
....................     if (pos.x < PLAYER_MIN_X) pos.x = PLAYER_MIN_X;
00C86:  MOVLB  4
00C88:  MOVF   xC7,W
00C8A:  SUBLW  4F
00C8C:  BNC   0C92
00C8E:  MOVLW  50
00C90:  MOVWF  xC7
....................     if (pos.x > PLAYER_MAX_X) pos.x = PLAYER_MAX_X;
00C92:  MOVF   xC7,W
00C94:  SUBLW  64
00C96:  BC    0C9C
00C98:  MOVLW  64
00C9A:  MOVWF  xC7
.................... 
....................     if (pos.y < PLAYER_TOP_Y) pos.y = PLAYER_TOP_Y;
....................     if (pos.y > PLAYER_BOT_Y) pos.y = PLAYER_BOT_Y;
00C9C:  MOVF   xC8,W
00C9E:  SUBLW  32
00CA0:  BC    0CA6
00CA2:  MOVLW  32
00CA4:  MOVWF  xC8
.................... 
....................     display_draw_player(pos);
00CA6:  MOVFF  4C8,4F7
00CAA:  MOVFF  4C7,4F6
00CAE:  MOVLB  0
00CB0:  RCALL  0518
....................     return pos;
00CB2:  MOVLB  4
00CB4:  MOVFF  4C7,01
00CB8:  MOVFF  4C8,02
00CBC:  MOVLB  0
00CBE:  GOTO   0D08 (RETURN)
.................... }
.................... 
.................... Enemy display_move_enemy(Enemy enemy){
*
01010:  MOVFF  4DA,4DF
01014:  MOVFF  4D9,4DE
....................     Vec2 last_pos = enemy.pos;
.................... 
....................     if (enemy.reached_y_edge != 0){
01018:  MOVLB  4
0101A:  MOVF   xDC,F
0101C:  BZ    105A
....................         enemy.pos.x += ENEMY_STEP_X;
0101E:  MOVLW  0D
01020:  ADDWF  xD9,F
....................         enemy.vdir = (enemy.reached_y_edge == 1)? 1 : -1;
01022:  DECFSZ xDC,W
01024:  BRA    102A
01026:  MOVLW  01
01028:  BRA    102C
0102A:  MOVLW  FF
0102C:  MOVWF  xDB
....................         enemy.reached_y_edge = 0;
0102E:  CLRF   xDC
.................... 
....................         display_clear_entity(last_pos, 8, 8);
01030:  MOVFF  4DF,4E1
01034:  MOVFF  4DE,4E0
01038:  MOVLW  08
0103A:  MOVWF  xE2
0103C:  MOVWF  xE3
0103E:  MOVLB  0
01040:  RCALL  0A5E
....................         display_draw_enemy(enemy.pos);
01042:  MOVFF  4DA,4F7
01046:  MOVFF  4D9,4F6
0104A:  CALL   0554
....................         return enemy;
0104E:  MOVLW  D8
01050:  MOVWF  01
01052:  MOVLW  04
01054:  MOVWF  02
01056:  BRA    10A4
01058:  MOVLB  4
....................     }
.................... 
....................     enemy.pos.y += enemy.vdir * ENEMY_STEP_Y;
0105A:  MOVF   xDB,W
0105C:  MULLW  05
0105E:  MOVF   FF3,W
01060:  ADDWF  xDA,F
.................... 
....................     if (enemy.pos.y <= ENEMY_TOP_Y){
01062:  MOVF   xDA,W
01064:  SUBLW  02
01066:  BNC   1072
....................         enemy.pos.y = ENEMY_TOP_Y;
01068:  MOVLW  02
0106A:  MOVWF  xDA
....................         enemy.reached_y_edge = 1;       //reached top
0106C:  MOVLW  01
0106E:  MOVWF  xDC
....................     }else if (enemy.pos.y >= ENEMY_BOT_Y){
01070:  BRA    107E
01072:  MOVF   xDA,W
01074:  SUBLW  31
01076:  BC    107E
....................         enemy.pos.y = ENEMY_BOT_Y;
01078:  MOVLW  32
0107A:  MOVWF  xDA
....................         enemy.reached_y_edge = -1;      //reached bottom
0107C:  SETF   xDC
....................     }
.................... 
....................     display_clear_entity(last_pos, 8, 8);
0107E:  MOVFF  4DF,4E1
01082:  MOVFF  4DE,4E0
01086:  MOVLW  08
01088:  MOVWF  xE2
0108A:  MOVWF  xE3
0108C:  MOVLB  0
0108E:  RCALL  0A5E
....................     display_draw_enemy(enemy.pos);
01090:  MOVFF  4DA,4F7
01094:  MOVFF  4D9,4F6
01098:  CALL   0554
.................... 
....................     return enemy;
0109C:  MOVLW  D8
0109E:  MOVWF  01
010A0:  MOVLW  04
010A2:  MOVWF  02
010A4:  GOTO   119E (RETURN)
.................... }
.................... 
.................... 
.................... Bullet display_move_bullet(Bullet bullet){
....................     if (!bullet.is_active) return bullet;
*
00D12:  MOVLB  4
00D14:  MOVF   xCA,F
00D16:  BNZ   0D2A
00D18:  MOVFF  4C7,00
00D1C:  MOVFF  4C8,01
00D20:  MOVFF  4C9,02
00D24:  MOVFF  4CA,03
00D28:  BRA    0D94
.................... 
....................     Vec2 last_pos = bullet.pos;
00D2A:  MOVFF  4C9,4CC
00D2E:  MOVFF  4C8,4CB
....................     bullet.pos.x -= BULLET_SPEED;
00D32:  MOVLW  0C
00D34:  SUBWF  xC8,F
.................... 
....................     if (bullet.pos.x <= BULLET_MIN_X){
00D36:  MOVF   xC8,W
00D38:  SUBLW  05
00D3A:  BNC   0D64
....................         display_clear_entity(last_pos, 8, 8);
00D3C:  MOVFF  4CC,4E1
00D40:  MOVFF  4CB,4E0
00D44:  MOVLW  08
00D46:  MOVWF  xE2
00D48:  MOVWF  xE3
00D4A:  MOVLB  0
00D4C:  RCALL  0A5E
....................         bullet.is_active = 0;
00D4E:  MOVLB  4
00D50:  CLRF   xCA
....................         return bullet;
00D52:  MOVFF  4C7,00
00D56:  MOVFF  4C8,01
00D5A:  MOVFF  4C9,02
00D5E:  MOVFF  4CA,03
00D62:  BRA    0D94
....................     }
.................... 
....................     display_clear_entity(last_pos, 8, 8);
00D64:  MOVFF  4CC,4E1
00D68:  MOVFF  4CB,4E0
00D6C:  MOVLW  08
00D6E:  MOVWF  xE2
00D70:  MOVWF  xE3
00D72:  MOVLB  0
00D74:  RCALL  0A5E
....................     display_draw_bullet(bullet.pos);
00D76:  MOVFF  4C9,4F7
00D7A:  MOVFF  4C8,4F6
00D7E:  CALL   0536
....................     
....................     return bullet;
00D82:  MOVFF  4C7,00
00D86:  MOVFF  4C8,01
00D8A:  MOVFF  4C9,02
00D8E:  MOVFF  4CA,03
00D92:  MOVLB  4
00D94:  MOVLB  0
00D96:  GOTO   0DB4 (RETURN)
.................... }
.................... 
.................... void display_gameover_screen(int score, int high_score){
....................     Vec2 gameover_pos = {46, 10};
*
01428:  MOVLW  2E
0142A:  MOVLB  4
0142C:  MOVWF  xC5
0142E:  MOVLW  0A
01430:  MOVWF  xC6
.................... 
....................     Vec2 hs_label_pos = {10, 20};
01432:  MOVWF  xC7
01434:  MOVLW  14
01436:  MOVWF  xC8
....................     Vec2 hs_pos = {10, 26};
01438:  MOVLW  0A
0143A:  MOVWF  xC9
0143C:  MOVLW  1A
0143E:  MOVWF  xCA
.................... 
....................     Vec2 ss_label_pos = {110, 20};
01440:  MOVLW  6E
01442:  MOVWF  xCB
01444:  MOVLW  14
01446:  MOVWF  xCC
....................     Vec2 ss_pos = {110, 26};
01448:  MOVLW  6E
0144A:  MOVWF  xCD
0144C:  MOVLW  1A
0144E:  MOVWF  xCE
.................... 
....................     Vec2 restart_label_pos = {32, 54};
01450:  MOVLW  20
01452:  MOVWF  xCF
01454:  MOVLW  36
01456:  MOVWF  xD0
.................... 
....................     int8 gameover_text[] = {'g', 'a', 'm', 'e', ' ', 'o', 'v', 'e', 'r'};
01458:  MOVLW  67
0145A:  MOVWF  xD1
0145C:  MOVLW  61
0145E:  MOVWF  xD2
01460:  MOVLW  6D
01462:  MOVWF  xD3
01464:  MOVLW  65
01466:  MOVWF  xD4
01468:  MOVLW  20
0146A:  MOVWF  xD5
0146C:  MOVLW  6F
0146E:  MOVWF  xD6
01470:  MOVLW  76
01472:  MOVWF  xD7
01474:  MOVLW  65
01476:  MOVWF  xD8
01478:  MOVLW  72
0147A:  MOVWF  xD9
....................     int8 hs_text[] = {'h', 's'};
0147C:  MOVLW  68
0147E:  MOVWF  xDA
01480:  MOVLW  73
01482:  MOVWF  xDB
....................     int8 ss_text[] = {'s', 's'};
01484:  MOVWF  xDC
01486:  MOVWF  xDD
....................     int8 click_to_restart_text[] = {
....................         'c', 'l', 'i', 'c', 'k', ' ',
....................         't', 'o', ' ',
....................         'r', 'e', 's', 't', 'a', 'r', 't'
....................     };
01488:  MOVLW  63
0148A:  MOVWF  xDE
0148C:  MOVLW  6C
0148E:  MOVWF  xDF
01490:  MOVLW  69
01492:  MOVWF  xE0
01494:  MOVLW  63
01496:  MOVWF  xE1
01498:  MOVLW  6B
0149A:  MOVWF  xE2
0149C:  MOVLW  20
0149E:  MOVWF  xE3
014A0:  MOVLW  74
014A2:  MOVWF  xE4
014A4:  MOVLW  6F
014A6:  MOVWF  xE5
014A8:  MOVLW  20
014AA:  MOVWF  xE6
014AC:  MOVLW  72
014AE:  MOVWF  xE7
014B0:  MOVLW  65
014B2:  MOVWF  xE8
014B4:  MOVLW  73
014B6:  MOVWF  xE9
014B8:  MOVLW  74
014BA:  MOVWF  xEA
014BC:  MOVLW  61
014BE:  MOVWF  xEB
014C0:  MOVLW  72
014C2:  MOVWF  xEC
014C4:  MOVLW  74
014C6:  MOVWF  xED
....................     
....................     display_draw_word(gameover_pos, gameover_text, 9);
014C8:  MOVFF  4C6,4F7
014CC:  MOVFF  4C5,4F6
014D0:  MOVLW  04
014D2:  MOVWF  xF9
014D4:  MOVLW  D1
014D6:  MOVWF  xF8
014D8:  MOVLW  09
014DA:  MOVWF  xFA
014DC:  MOVLB  0
014DE:  CALL   047C
....................     display_draw_word(hs_label_pos, hs_text, 2);
014E2:  MOVFF  4C8,4F7
014E6:  MOVFF  4C7,4F6
014EA:  MOVLW  04
014EC:  MOVLB  4
014EE:  MOVWF  xF9
014F0:  MOVLW  DA
014F2:  MOVWF  xF8
014F4:  MOVLW  02
014F6:  MOVWF  xFA
014F8:  MOVLB  0
014FA:  CALL   047C
....................     display_draw_word(ss_label_pos, ss_text, 2);
014FE:  MOVFF  4CC,4F7
01502:  MOVFF  4CB,4F6
01506:  MOVLW  04
01508:  MOVLB  4
0150A:  MOVWF  xF9
0150C:  MOVLW  DC
0150E:  MOVWF  xF8
01510:  MOVLW  02
01512:  MOVWF  xFA
01514:  MOVLB  0
01516:  CALL   047C
....................     display_draw_word(restart_label_pos, click_to_restart_text, 16);
0151A:  MOVFF  4D0,4F7
0151E:  MOVFF  4CF,4F6
01522:  MOVLW  04
01524:  MOVLB  4
01526:  MOVWF  xF9
01528:  MOVLW  DE
0152A:  MOVWF  xF8
0152C:  MOVLW  10
0152E:  MOVWF  xFA
01530:  MOVLB  0
01532:  CALL   047C
.................... 
....................     display_draw_number(hs_pos, high_score);
01536:  MOVFF  4CA,4EF
0153A:  MOVFF  4C9,4EE
0153E:  MOVFF  4C4,4F0
01542:  CALL   087A
....................     display_draw_number(ss_pos, score);
01546:  MOVFF  4CE,4EF
0154A:  MOVFF  4CD,4EE
0154E:  MOVFF  4C3,4F0
01552:  CALL   087A
01556:  GOTO   1578 (RETURN)
.................... }
.................... 
.................... void display_start_screen(){
....................     Vec2 title_pos = {8, 5};
*
00572:  MOVLW  08
00574:  MOVLB  4
00576:  MOVWF  xC2
00578:  MOVLW  05
0057A:  MOVWF  xC3
....................     Vec2 start_pos = {36, 59};
0057C:  MOVLW  24
0057E:  MOVWF  xC4
00580:  MOVLW  3B
00582:  MOVWF  xC5
.................... 
....................     Vec2 enemy_pos  = {10, 32};
00584:  MOVLW  0A
00586:  MOVWF  xC6
00588:  MOVLW  20
0058A:  MOVWF  xC7
....................     Vec2 bullet_pos = {50, 32};
0058C:  MOVLW  32
0058E:  MOVWF  xC8
00590:  MOVLW  20
00592:  MOVWF  xC9
....................     Vec2 player_pos = {90, 32};
00594:  MOVLW  5A
00596:  MOVWF  xCA
00598:  MOVLW  20
0059A:  MOVWF  xCB
.................... 
....................     int8 title_text[] = {
....................         's', 'p', 'a', 'c', 'e', ' ',
....................         'i', 'n', 'v', 'a', 'd', 'e', 'r', 's',
....................         ' ', ' ', ' ',
....................         'p', 'i', 'c', ' ',
....................         'e', 'd', 'i', 't', 'i', 'o', 'n'
....................     };
0059C:  MOVLW  73
0059E:  MOVWF  xCC
005A0:  MOVLW  70
005A2:  MOVWF  xCD
005A4:  MOVLW  61
005A6:  MOVWF  xCE
005A8:  MOVLW  63
005AA:  MOVWF  xCF
005AC:  MOVLW  65
005AE:  MOVWF  xD0
005B0:  MOVLW  20
005B2:  MOVWF  xD1
005B4:  MOVLW  69
005B6:  MOVWF  xD2
005B8:  MOVLW  6E
005BA:  MOVWF  xD3
005BC:  MOVLW  76
005BE:  MOVWF  xD4
005C0:  MOVLW  61
005C2:  MOVWF  xD5
005C4:  MOVLW  64
005C6:  MOVWF  xD6
005C8:  MOVLW  65
005CA:  MOVWF  xD7
005CC:  MOVLW  72
005CE:  MOVWF  xD8
005D0:  MOVLW  73
005D2:  MOVWF  xD9
005D4:  MOVLW  20
005D6:  MOVWF  xDA
005D8:  MOVWF  xDB
005DA:  MOVWF  xDC
005DC:  MOVLW  70
005DE:  MOVWF  xDD
005E0:  MOVLW  69
005E2:  MOVWF  xDE
005E4:  MOVLW  63
005E6:  MOVWF  xDF
005E8:  MOVLW  20
005EA:  MOVWF  xE0
005EC:  MOVLW  65
005EE:  MOVWF  xE1
005F0:  MOVLW  64
005F2:  MOVWF  xE2
005F4:  MOVLW  69
005F6:  MOVWF  xE3
005F8:  MOVLW  74
005FA:  MOVWF  xE4
005FC:  MOVLW  69
005FE:  MOVWF  xE5
00600:  MOVLW  6F
00602:  MOVWF  xE6
00604:  MOVLW  6E
00606:  MOVWF  xE7
.................... 
....................     int8 start_text[] = {
....................         'c', 'l', 'i', 'c', 'k', ' ',
....................         't', 'o', ' ',
....................         's', 't', 'a', 'r', 't'
....................     };
00608:  MOVLW  63
0060A:  MOVWF  xE8
0060C:  MOVLW  6C
0060E:  MOVWF  xE9
00610:  MOVLW  69
00612:  MOVWF  xEA
00614:  MOVLW  63
00616:  MOVWF  xEB
00618:  MOVLW  6B
0061A:  MOVWF  xEC
0061C:  MOVLW  20
0061E:  MOVWF  xED
00620:  MOVLW  74
00622:  MOVWF  xEE
00624:  MOVLW  6F
00626:  MOVWF  xEF
00628:  MOVLW  20
0062A:  MOVWF  xF0
0062C:  MOVLW  73
0062E:  MOVWF  xF1
00630:  MOVLW  74
00632:  MOVWF  xF2
00634:  MOVLW  61
00636:  MOVWF  xF3
00638:  MOVLW  72
0063A:  MOVWF  xF4
0063C:  MOVLW  74
0063E:  MOVWF  xF5
.................... 
....................     display_draw_word(title_pos, title_text, 28);
00640:  MOVFF  4C3,4F7
00644:  MOVFF  4C2,4F6
00648:  MOVLW  04
0064A:  MOVWF  xF9
0064C:  MOVLW  CC
0064E:  MOVWF  xF8
00650:  MOVLW  1C
00652:  MOVWF  xFA
00654:  MOVLB  0
00656:  RCALL  047C
....................     display_draw_word(start_pos, start_text, 14);
00658:  MOVFF  4C5,4F7
0065C:  MOVFF  4C4,4F6
00660:  MOVLW  04
00662:  MOVLB  4
00664:  MOVWF  xF9
00666:  MOVLW  E8
00668:  MOVWF  xF8
0066A:  MOVLW  0E
0066C:  MOVWF  xFA
0066E:  MOVLB  0
00670:  RCALL  047C
.................... 
....................     display_draw_player(player_pos);
00672:  MOVFF  4CB,4F7
00676:  MOVFF  4CA,4F6
0067A:  RCALL  0518
....................     display_draw_bullet(bullet_pos);
0067C:  MOVFF  4C9,4F7
00680:  MOVFF  4C8,4F6
00684:  RCALL  0536
....................     display_draw_enemy(enemy_pos);
00686:  MOVFF  4C7,4F7
0068A:  MOVFF  4C6,4F6
0068E:  RCALL  0554
00690:  GOTO   06E0 (RETURN)
.................... }
.................... 
.................... //memory.c
.................... //memory.c
.................... //complete
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "../Drivers/eeprom_24LC512.h"
.................... //24LC512.h     i2c eeprom driver
.................... #ifndef EEPROM_24LC512
.................... #define EEPROM_24LC512
.................... 
.................... #define EEPROM_ADDR_WRITE  0xA0
.................... #define EEPROM_ADDR_READ   0xA1
.................... 
.................... #define STATE_ADDR 0x0000
.................... 
.................... void eeprom_write_byte(BYTE data);
.................... BYTE eeprom_read_byte();
.................... 
.................... #endif
.................... 
.................... 
.................... int load_highscore(){
*
013BA:  BRA    1368
013BC:  MOVFF  01,4C3
....................     int highscore = eeprom_read_byte();
....................     return highscore;
013C0:  MOVLB  4
013C2:  MOVFF  4C3,01
013C6:  MOVLB  0
013C8:  GOTO   155C (RETURN)
.................... }
.................... 
.................... void save_highscore(int score, int hs){
....................     if (score > hs){
*
01410:  MOVLB  4
01412:  MOVF   xC3,W
01414:  SUBWF  xC4,W
01416:  BC    1422
....................         eeprom_write_byte(score);
01418:  MOVFF  4C3,4C5
0141C:  MOVLB  0
0141E:  BRA    13CC
01420:  MOVLB  4
....................     }
01422:  MOVLB  0
01424:  GOTO   156A (RETURN)
.................... }
.................... 
.................... /*
.................... /*
....................     Contains collision system 
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "entities.h"
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... //type contains p for player
.................... //              e for enemies
.................... //              b for bullet
.................... //this will help with detecting collisions later
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int vdir;   //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "sprites.h"
.................... #ifndef SPRITES_H
.................... #define SPRITES_H
.................... 
.................... #define SPRITE_SIZE 8 
.................... 
.................... extern  int8 PLAYER_SPRITE[8];
.................... extern  int8 ENEMY_SPRITE[8];
.................... extern  int8 BULLET_SPRITE[8];
.................... 
.................... #endif
.................... 
.................... 
.................... int check_collisionBE(Bullet b, Enemy e){
....................     return (b.pos.x < e.pos.x + SPRITE_SIZE) &&
....................     (b.pos.x + SPRITE_SIZE > e.pos.x) &&
....................     (b.pos.y < e.pos.y + SPRITE_SIZE) &&
....................     (b.pos.y + SPRITE_SIZE > e.pos.y);
*
00DCA:  MOVLW  08
00DCC:  MOVLB  4
00DCE:  ADDWF  xD4,W
00DD0:  SUBWF  xD0,W
00DD2:  BC    0DEC
00DD4:  MOVLW  08
00DD6:  ADDWF  xD0,W
00DD8:  SUBWF  xD4,W
00DDA:  BC    0DEC
00DDC:  MOVLW  08
00DDE:  ADDWF  xD5,W
00DE0:  SUBWF  xD1,W
00DE2:  BC    0DEC
00DE4:  MOVLW  08
00DE6:  ADDWF  xD1,W
00DE8:  SUBWF  xD5,W
00DEA:  BNC   0DF0
00DEC:  MOVLW  00
00DEE:  BRA    0DF2
00DF0:  MOVLW  01
00DF2:  MOVWF  01
00DF4:  MOVLB  0
00DF6:  GOTO   0EBE (RETURN)
.................... }
.................... 
.................... #include <18F46K22.h>
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "sprites.h"
.................... #ifndef SPRITES_H
.................... #define SPRITES_H
.................... 
.................... #define SPRITE_SIZE 8 
.................... 
.................... extern  int8 PLAYER_SPRITE[8];
.................... extern  int8 ENEMY_SPRITE[8];
.................... extern  int8 BULLET_SPRITE[8];
.................... 
.................... #endif
.................... 
.................... 
.................... int8 PLAYER_SPRITE[8] = {
....................     0x70, 0x8c, 0x82, 0x81, 0x81, 0x82, 0x8c, 0x70
.................... };
.................... 
.................... int8 ENEMY_SPRITE[8] = {
....................     0x18, 0x24, 0x42, 0x81, 0x42, 0x5a, 0x24, 0xc3
.................... };
.................... 
.................... int8 BULLET_SPRITE[8] = {
....................     0x00, 0x00, 0x00, 0x7e, 0x7e, 0x00, 0x00, 0x00
.................... };
.................... 
.................... #include <18F46K22.h>
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #fuses INTRC_IO, NOWDT, NOLVP, NOPROTECT
.................... #use delay(clock=16MHz)
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)
.................... 
.................... #include "API/display.h"
.................... #ifndef DISPLAY_H
.................... #define DISPLAY_H
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... //type contains p for player
.................... //              e for enemies
.................... //              b for bullet
.................... //this will help with detecting collisions later
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int vdir;   //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void display_init();
.................... void display_clear();
.................... void display_update();
.................... 
.................... void display_gameover_screen(int score, int high_score);
.................... void display_start_screen();
.................... 
.................... void display_draw_digit(Vec2 pos, int digit);
.................... void display_draw_number(Vec2 pos, int number);
.................... void display_count_0_to_100();
.................... 
.................... void display_draw_letter(Vec2 pos, char c);
.................... void display_draw_word(Vec2 pos, int8 word[], int length);
.................... 
.................... void display_draw_player(Vec2 pos);
.................... void display_draw_enemy(Vec2 pos);
.................... void display_draw_bullet(Vec2 pos);
.................... void display_draw_score(int score);
.................... 
.................... void display_clear_score();
.................... 
.................... void display_clear_entity(Vec2 pos, int h, int w);
.................... void display_draw_entity(Vec2 pos, int8 sprite[], int h, int w);
.................... 
.................... Vec2 display_move_player(Vec2 pos);
.................... Enemy display_move_enemy(Enemy enemy);
.................... Bullet display_move_bullet(Bullet bullet);
.................... 
.................... #endif
.................... 
.................... #include "API/controller.h"
.................... #ifndef CONTROLLER_H
.................... #define CONTROLLER_H
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... 
.................... //type contains p for player
.................... //              e for enemies
.................... //              b for bullet
.................... //this will help with detecting collisions later
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int vdir;   //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void controller_init();
.................... void controller_update(Vec2 *pos);
.................... void controller_update_button_only();
.................... 
.................... int1 is_button_pressed();
.................... int1 is_button_just_pressed();
.................... int1 is_button_just_released();
.................... 
.................... void controller_shoot(Player p, Bullet *b);
.................... 
.................... #endif
.................... 
.................... #include "API/memory.h"
.................... #ifndef MEMORY_H
.................... #define MEMORY_H
.................... 
.................... int load_highscore();
.................... void save_highscore(int score, int hs); //score needs to be 8 bit max
.................... 
.................... #endif
.................... 
.................... #include "Utilities/entities.h"
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... 
.................... //type contains p for player
.................... //              e for enemies
.................... //              b for bullet
.................... //this will help with detecting collisions later
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int vdir;   //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     char type;
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... #include "Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... #include "simple_scheduler.h"
.................... #ifndef SIMPLE_SCHEDULER_H
.................... #define SIMPLE_SCHEDULER_H
.................... 
.................... typedef void (*task_fn_t)(void);
.................... 
.................... #define SCHED_MAX_TASKS 6
.................... 
.................... typedef struct{
....................     task_fn_t fn;
....................     unsigned char active; //0 if unused, 1 if active
.................... } Task;
.................... 
.................... typedef struct{
....................     unsigned char count;
.................... } Semaphore;
.................... 
.................... typedef struct{
....................     unsigned char full; //0 if empty, 1 if full
....................     unsigned char data[8]; //size can be changed
.................... } Mailbox;
.................... 
.................... /*Scheduler API*/
.................... void sched_init(void);
.................... int sched_add_task(task_fn_t fn);
.................... void sched_run_cycle(void); //run one cycle
.................... void sched_run_forever(unsigned int cycle_delay_ms);
.................... 
.................... void sched_yield(void);
.................... 
.................... /*Semaphore API*/
.................... void sem_init(Semaphore *s, unsigned char init);
.................... unsigned char sem_trywait(Semaphore *s);
.................... void sem_wait(Semaphore *s);    /* blocks co-operatively: sets count-- if >0 else returns 0 so task can yield */
.................... void sem_signal(Semaphore *s);
.................... 
.................... /*mailbox*/
.................... void mbox_init(Mailbox *m);
.................... unsigned char mbox_send(Mailbox *m, int8 buf[], int8 size);
.................... unsigned char mbox_receive(Mailbox *m, int8 out[], int8 size);
.................... 
.................... #endif
.................... 
.................... 
.................... #define ENEMIES_PER_WAVE     3
.................... #define ENEMY_X_LIMIT        75
.................... 
.................... Enemy enemies[ENEMIES_PER_WAVE];
.................... Player p = {'p', {80, 50}};
.................... Bullet b = {'b', {0, 0}, 0};
.................... int score = 0;
.................... int last_score = 0;
.................... int wave_spawned = 0;
.................... int game_over_flag = 0;
.................... 
.................... Semaphore enemy_move_sem;
.................... int enemy_move_interval = 6;
.................... int frame_counter = 0;
.................... 
.................... Mailbox collision_mbox;
.................... 
.................... // Spawns a wave of enemies in their starting positions
.................... void spawn_enemy_wave() {
....................     Enemy new_wave[ENEMIES_PER_WAVE] = {
....................         { 'e',  {5,  5}, 1, 0, 1 },  // enemies[0]
....................         { 'e',  {5, 25}, 1, 0, 1 },  // enemies[1]
....................         //{ 'e',  {5, 45}, 1, 0, 1 },  // enemies[2]
....................         //{ 'e', {30,  5}, 1, 0, 1 },  // enemies[3]
....................         //{ 'e', {30, 25}, 1, 0, 1 },  // enemies[4]
....................         { 'e', {30, 45}, 1, 0, 1 }   // enemies[5]
....................     };
*
00708:  MOVLW  65
0070A:  MOVLB  4
0070C:  MOVWF  xCA
0070E:  MOVLW  05
00710:  MOVWF  xCB
00712:  MOVWF  xCC
00714:  MOVLW  01
00716:  MOVWF  xCD
00718:  CLRF   xCE
0071A:  MOVWF  xCF
0071C:  MOVLW  65
0071E:  MOVWF  xD0
00720:  MOVLW  05
00722:  MOVWF  xD1
00724:  MOVLW  19
00726:  MOVWF  xD2
00728:  MOVLW  01
0072A:  MOVWF  xD3
0072C:  CLRF   xD4
0072E:  MOVWF  xD5
00730:  MOVLW  65
00732:  MOVWF  xD6
00734:  MOVLW  1E
00736:  MOVWF  xD7
00738:  MOVLW  2D
0073A:  MOVWF  xD8
0073C:  MOVLW  01
0073E:  MOVWF  xD9
00740:  CLRF   xDA
00742:  MOVWF  xDB
.................... 
....................     for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
00744:  CLRF   xDC
00746:  MOVF   xDC,W
00748:  SUBLW  02
0074A:  BNC   07BC
....................         enemies[i] = new_wave[i];
0074C:  MOVF   xDC,W
0074E:  MULLW  06
00750:  MOVF   FF3,W
00752:  CLRF   03
00754:  ADDLW  87
00756:  MOVWF  01
00758:  MOVLW  04
0075A:  ADDWFC 03,F
0075C:  MOVFF  01,4DD
00760:  MOVFF  03,FEA
00764:  MOVF   xDC,W
00766:  MULLW  06
00768:  MOVF   FF3,W
0076A:  CLRF   03
0076C:  ADDLW  CA
0076E:  MOVWF  FE1
00770:  MOVLW  04
00772:  ADDWFC 03,W
00774:  MOVWF  FE2
00776:  MOVFF  01,FE9
0077A:  MOVLW  06
0077C:  MOVWF  01
0077E:  MOVFF  FE6,FEE
00782:  DECFSZ 01,F
00784:  BRA    077E
....................         display_draw_enemy(enemies[i].pos);
00786:  MOVF   xDC,W
00788:  MULLW  06
0078A:  MOVF   FF3,W
0078C:  CLRF   xDE
0078E:  MOVWF  xDD
00790:  MOVLW  01
00792:  ADDWF  xDD,W
00794:  MOVWF  01
00796:  MOVLW  00
00798:  ADDWFC xDE,W
0079A:  MOVWF  03
0079C:  MOVF   01,W
0079E:  ADDLW  87
007A0:  MOVWF  FE9
007A2:  MOVLW  04
007A4:  ADDWFC 03,W
007A6:  MOVWF  FEA
007A8:  MOVFF  FEC,4F7
007AC:  MOVF   FED,F
007AE:  MOVFF  FEF,4F6
007B2:  MOVLB  0
007B4:  RCALL  0554
007B6:  MOVLB  4
007B8:  INCF   xDC,F
007BA:  BRA    0746
....................     }
007BC:  MOVLB  0
007BE:  RETURN 0
.................... }
.................... 
.................... void task_player(void){
....................     display_clear_entity(p.pos, 8, 8);
*
00CC2:  MOVFF  49B,4E1
00CC6:  MOVFF  49A,4E0
00CCA:  MOVLW  08
00CCC:  MOVLB  4
00CCE:  MOVWF  xE2
00CD0:  MOVWF  xE3
00CD2:  MOVLB  0
00CD4:  RCALL  0A5E
....................     controller_update(&p.pos);
00CD6:  MOVLW  04
00CD8:  MOVLB  4
00CDA:  MOVWF  xC8
00CDC:  MOVLW  9A
00CDE:  MOVWF  xC7
00CE0:  MOVLB  0
00CE2:  BRA    0ADE
....................     controller_shoot(p, &b);
00CE4:  MOVFF  49B,4C9
00CE8:  MOVFF  49A,4C8
00CEC:  MOVFF  499,4C7
00CF0:  MOVLW  04
00CF2:  MOVLB  4
00CF4:  MOVWF  xCB
00CF6:  MOVLW  9C
00CF8:  MOVWF  xCA
00CFA:  MOVLB  0
00CFC:  BRA    0C16
....................     p.pos = display_move_player(p.pos);
00CFE:  MOVFF  49B,4C8
00D02:  MOVFF  49A,4C7
00D06:  BRA    0C6A
00D08:  MOVFF  02,49B
00D0C:  MOVFF  01,49A
00D10:  RETURN 0
.................... }
.................... 
.................... void task_bullet(void){
....................     if (b.is_active){
*
00D9A:  MOVLB  4
00D9C:  MOVF   x9F,F
00D9E:  BZ    0DC6
....................         b = display_move_bullet(b);
00DA0:  MOVFF  49F,4CA
00DA4:  MOVFF  49E,4C9
00DA8:  MOVFF  49D,4C8
00DAC:  MOVFF  49C,4C7
00DB0:  MOVLB  0
00DB2:  BRA    0D12
00DB4:  MOVFF  03,49F
00DB8:  MOVFF  02,49E
00DBC:  MOVFF  01,49D
00DC0:  MOVFF  00,49C
00DC4:  MOVLB  4
....................     }
00DC6:  MOVLB  0
00DC8:  RETURN 0
.................... }
.................... 
.................... void task_collision(void){
....................     for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
*
00E5E:  MOVLB  4
00E60:  CLRF   xC7
00E62:  MOVF   xC7,W
00E64:  SUBLW  02
00E66:  BTFSS  FD8.0
00E68:  BRA    0F94
....................         if (check_collisionBE(b, enemies[i]) && b.is_active && enemies[i].is_active) {
00E6A:  MOVF   xC7,W
00E6C:  MULLW  06
00E6E:  MOVF   FF3,W
00E70:  CLRF   03
00E72:  ADDLW  87
00E74:  MOVWF  FE9
00E76:  MOVLW  04
00E78:  ADDWFC 03,W
00E7A:  MOVWF  FEA
00E7C:  MOVF   FEE,F
00E7E:  MOVF   FEE,F
00E80:  MOVF   FEE,F
00E82:  MOVF   FEE,F
00E84:  MOVFF  FEC,4D8
00E88:  MOVF   FED,F
00E8A:  MOVFF  FEF,4D7
00E8E:  MOVF   FED,F
00E90:  MOVFF  FEF,4D6
00E94:  MOVF   FED,F
00E96:  MOVFF  FEF,4D5
00E9A:  MOVF   FED,F
00E9C:  MOVFF  FEF,4CA
00EA0:  MOVF   FED,F
00EA2:  MOVFF  FEF,4D3
00EA6:  MOVFF  49F,4D2
00EAA:  MOVFF  49E,4D1
00EAE:  MOVFF  49D,4D0
00EB2:  MOVFF  49C,4CF
00EB6:  MOVFF  4CA,4D4
00EBA:  MOVLB  0
00EBC:  BRA    0DCA
00EBE:  MOVF   01,F
00EC0:  BZ    0F8E
00EC2:  MOVLB  4
00EC4:  MOVF   x9F,F
00EC6:  BTFSS  FD8.2
00EC8:  BRA    0ECE
00ECA:  MOVLB  0
00ECC:  BRA    0F8E
00ECE:  MOVF   xC7,W
00ED0:  MULLW  06
00ED2:  MOVF   FF3,W
00ED4:  CLRF   xCA
00ED6:  MOVWF  xC9
00ED8:  MOVLW  05
00EDA:  ADDWF  xC9,W
00EDC:  MOVWF  01
00EDE:  MOVLW  00
00EE0:  ADDWFC xCA,W
00EE2:  MOVWF  03
00EE4:  MOVF   01,W
00EE6:  ADDLW  87
00EE8:  MOVWF  FE9
00EEA:  MOVLW  04
00EEC:  ADDWFC 03,W
00EEE:  MOVWF  FEA
00EF0:  MOVF   FEF,F
00EF2:  BTFSS  FD8.2
00EF4:  BRA    0EFA
00EF6:  MOVLB  0
00EF8:  BRA    0F8E
....................             int8 hit_flag[1] = {1};
00EFA:  MOVLW  01
00EFC:  MOVWF  xC8
.................... 
....................             mbox_send(&collision_mbox, hit_flag, 1);
00EFE:  MOVLW  04
00F00:  MOVWF  xCA
00F02:  MOVLW  A7
00F04:  MOVWF  xC9
00F06:  MOVLW  04
00F08:  MOVWF  xCC
00F0A:  MOVLW  C8
00F0C:  MOVWF  xCB
00F0E:  MOVLW  01
00F10:  MOVWF  xCD
00F12:  MOVLB  0
00F14:  BRA    0DFA
.................... 
....................             b.is_active = 0;
00F16:  MOVLB  4
00F18:  CLRF   x9F
....................             enemies[i].is_active = 0;
00F1A:  MOVF   xC7,W
00F1C:  MULLW  06
00F1E:  MOVF   FF3,W
00F20:  CLRF   xCA
00F22:  MOVWF  xC9
00F24:  MOVLW  05
00F26:  ADDWF  xC9,W
00F28:  MOVWF  01
00F2A:  MOVLW  00
00F2C:  ADDWFC xCA,W
00F2E:  MOVWF  03
00F30:  MOVF   01,W
00F32:  ADDLW  87
00F34:  MOVWF  FE9
00F36:  MOVLW  04
00F38:  ADDWFC 03,W
00F3A:  MOVWF  FEA
00F3C:  CLRF   FEF
....................             display_clear_entity(enemies[i].pos, 8, 8);
00F3E:  MOVF   xC7,W
00F40:  MULLW  06
00F42:  MOVF   FF3,W
00F44:  CLRF   xCA
00F46:  MOVWF  xC9
00F48:  MOVLW  01
00F4A:  ADDWF  xC9,W
00F4C:  MOVWF  01
00F4E:  MOVLW  00
00F50:  ADDWFC xCA,W
00F52:  MOVWF  03
00F54:  MOVF   01,W
00F56:  ADDLW  87
00F58:  MOVWF  FE9
00F5A:  MOVLW  04
00F5C:  ADDWFC 03,W
00F5E:  MOVWF  FEA
00F60:  MOVFF  FEC,4E1
00F64:  MOVF   FED,F
00F66:  MOVFF  FEF,4E0
00F6A:  MOVLW  08
00F6C:  MOVWF  xE2
00F6E:  MOVWF  xE3
00F70:  MOVLB  0
00F72:  RCALL  0A5E
....................             display_clear_entity(b.pos, 8, 8);
00F74:  MOVFF  49E,4E1
00F78:  MOVFF  49D,4E0
00F7C:  MOVLW  08
00F7E:  MOVLB  4
00F80:  MOVWF  xE2
00F82:  MOVWF  xE3
00F84:  MOVLB  0
00F86:  RCALL  0A5E
....................             break;
00F88:  MOVLB  4
00F8A:  BRA    0F94
00F8C:  MOVLB  0
....................         }
00F8E:  MOVLB  4
00F90:  INCF   xC7,F
00F92:  BRA    0E62
....................     }
00F94:  MOVLB  0
00F96:  RETURN 0
.................... }
.................... 
.................... void task_display(void) {
....................     display_update();
*
00FB2:  CALL   028E
....................     frame_counter++;
00FB6:  MOVLB  4
00FB8:  INCF   xA6,F
.................... 
....................     if (frame_counter % enemy_move_interval == 0){
00FBA:  MOVFF  4A6,4FB
00FBE:  MOVFF  4A5,4FC
00FC2:  MOVLB  0
00FC4:  RCALL  084E
00FC6:  MOVF   00,F
00FC8:  BNZ   0FD8
....................         sem_signal(&enemy_move_sem);
00FCA:  MOVLW  04
00FCC:  MOVLB  4
00FCE:  MOVWF  xC8
00FD0:  MOVLW  A4
00FD2:  MOVWF  xC7
00FD4:  MOVLB  0
00FD6:  BRA    0F98
....................     }
00FD8:  RETURN 0
.................... }
.................... 
.................... void task_enemies(void) {
*
010A8:  MOVLB  4
010AA:  CLRF   xC7
....................     int active_count = 0;
....................     for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
010AC:  CLRF   xC8
010AE:  MOVF   xC8,W
010B0:  SUBLW  02
010B2:  BNC   10E0
....................         if (enemies[i].is_active) {
010B4:  MOVF   xC8,W
010B6:  MULLW  06
010B8:  MOVF   FF3,W
010BA:  CLRF   xCB
010BC:  MOVWF  xCA
010BE:  MOVLW  05
010C0:  ADDWF  xCA,W
010C2:  MOVWF  01
010C4:  MOVLW  00
010C6:  ADDWFC xCB,W
010C8:  MOVWF  03
010CA:  MOVF   01,W
010CC:  ADDLW  87
010CE:  MOVWF  FE9
010D0:  MOVLW  04
010D2:  ADDWFC 03,W
010D4:  MOVWF  FEA
010D6:  MOVF   FEF,F
010D8:  BZ    10DC
....................             active_count++;
010DA:  INCF   xC7,F
....................         }
010DC:  INCF   xC8,F
010DE:  BRA    10AE
....................     }
....................     if (active_count == 0 && !wave_spawned) {
010E0:  MOVF   xC7,F
010E2:  BNZ   10FC
010E4:  MOVF   xA2,F
010E6:  BNZ   10FC
....................         if (enemy_move_interval > 1) {
010E8:  MOVF   xA5,W
010EA:  SUBLW  01
010EC:  BC    10F0
....................             enemy_move_interval--;
010EE:  DECF   xA5,F
....................         }
....................         spawn_enemy_wave();
010F0:  MOVLB  0
010F2:  CALL   0708
....................         wave_spawned = 1;
010F6:  MOVLW  01
010F8:  MOVLB  4
010FA:  MOVWF  xA2
....................     }
....................     if (wave_spawned && active_count > 0) {
010FC:  MOVF   xA2,F
010FE:  BZ    1106
01100:  MOVF   xC7,F
01102:  BZ    1106
....................         wave_spawned = 0;
01104:  CLRF   xA2
....................     }
.................... 
....................     if (sem_trywait(&enemy_move_sem)) {
01106:  MOVLW  04
01108:  MOVWF  xCB
0110A:  MOVLW  A4
0110C:  MOVWF  xCA
0110E:  MOVLB  0
01110:  BRA    0FDA
01112:  MOVF   01,F
01114:  BZ    11EE
....................         for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
01116:  MOVLB  4
01118:  CLRF   xC9
0111A:  MOVF   xC9,W
0111C:  SUBLW  02
0111E:  BNC   11EC
....................             if (enemies[i].is_active) {
01120:  MOVF   xC9,W
01122:  MULLW  06
01124:  MOVF   FF3,W
01126:  CLRF   xCB
01128:  MOVWF  xCA
0112A:  MOVLW  05
0112C:  ADDWF  xCA,W
0112E:  MOVWF  01
01130:  MOVLW  00
01132:  ADDWFC xCB,W
01134:  MOVWF  03
01136:  MOVF   01,W
01138:  ADDLW  87
0113A:  MOVWF  FE9
0113C:  MOVLW  04
0113E:  ADDWFC 03,W
01140:  MOVWF  FEA
01142:  MOVF   FEF,F
01144:  BZ    11E8
....................                 enemies[i] = display_move_enemy(enemies[i]);
01146:  MOVF   xC9,W
01148:  MULLW  06
0114A:  MOVF   FF3,W
0114C:  CLRF   03
0114E:  ADDLW  87
01150:  MOVWF  01
01152:  MOVLW  04
01154:  ADDWFC 03,F
01156:  MOVFF  01,4CA
0115A:  MOVFF  03,4CB
0115E:  MOVF   xC9,W
01160:  MULLW  06
01162:  MOVF   FF3,W
01164:  CLRF   03
01166:  ADDLW  87
01168:  MOVWF  FE9
0116A:  MOVLW  04
0116C:  ADDWFC 03,W
0116E:  MOVWF  FEA
01170:  MOVF   FEE,F
01172:  MOVF   FEE,F
01174:  MOVF   FEE,F
01176:  MOVF   FEE,F
01178:  MOVFF  FEC,4DD
0117C:  MOVF   FED,F
0117E:  MOVFF  FEF,4DC
01182:  MOVF   FED,F
01184:  MOVFF  FEF,4DB
01188:  MOVF   FED,F
0118A:  MOVFF  FEF,4DA
0118E:  MOVF   FED,F
01190:  MOVFF  FEF,4D9
01194:  MOVF   FED,F
01196:  MOVFF  FEF,4D8
0119A:  MOVLB  0
0119C:  BRA    1010
0119E:  MOVFF  02,03
011A2:  MOVFF  01,FE1
011A6:  MOVFF  02,FE2
011AA:  MOVFF  4CB,FEA
011AE:  MOVFF  4CA,FE9
011B2:  MOVLW  06
011B4:  MOVWF  01
011B6:  MOVFF  FE6,FEE
011BA:  DECFSZ 01,F
011BC:  BRA    11B6
....................                 if (enemies[i].pos.x >= ENEMY_X_LIMIT) {
011BE:  MOVLB  4
011C0:  MOVF   xC9,W
011C2:  MULLW  06
011C4:  MOVF   FF3,W
011C6:  CLRF   xCB
011C8:  MOVWF  xCA
011CA:  MOVLW  01
011CC:  ADDWF  xCA,F
011CE:  MOVLW  00
011D0:  ADDWFC xCB,F
011D2:  MOVLW  87
011D4:  ADDWF  xCA,W
011D6:  MOVWF  FE9
011D8:  MOVLW  04
011DA:  ADDWFC xCB,W
011DC:  MOVWF  FEA
011DE:  MOVF   FEF,W
011E0:  SUBLW  4A
011E2:  BC    11E8
....................                     game_over_flag = 1; // signal to stop scheduler
011E4:  MOVLW  01
011E6:  MOVWF  xA3
....................                 }
....................             }
011E8:  INCF   xC9,F
011EA:  BRA    111A
011EC:  MOVLB  0
....................         }
....................     }
011EE:  RETURN 0
.................... }
.................... 
.................... void task_score(void) {
....................     int8 hit_flag[1];
.................... 
....................     while (mbox_receive(&collision_mbox, hit_flag, 1)){
*
01276:  MOVLW  04
01278:  MOVLB  4
0127A:  MOVWF  xC9
0127C:  MOVLW  A7
0127E:  MOVWF  xC8
01280:  MOVLW  04
01282:  MOVWF  xCB
01284:  MOVLW  C7
01286:  MOVWF  xCA
01288:  MOVLW  01
0128A:  MOVWF  xCC
0128C:  MOVLB  0
0128E:  BRA    11F0
01290:  MOVF   01,F
01292:  BZ    12A0
....................         if (hit_flag[0] == 1) score++;
01294:  MOVLB  4
01296:  DECFSZ xC7,W
01298:  BRA    129C
0129A:  INCF   xA0,F
0129C:  MOVLB  0
0129E:  BRA    1276
....................     }
.................... 
....................     if (score != last_score) {
012A0:  MOVLB  4
012A2:  MOVF   xA1,W
012A4:  SUBWF  xA0,W
012A6:  BZ    12BA
....................         display_clear_score();
012A8:  MOVLB  0
012AA:  BRA    1254
....................         display_draw_score(score);
012AC:  MOVFF  4A0,4C8
012B0:  CALL   0968
....................         last_score = score;
012B4:  MOVFF  4A0,4A1
012B8:  MOVLB  4
....................     }
012BA:  MOVLB  0
012BC:  RETURN 0
.................... }
.................... 
.................... void start_screen_loop() {
....................     display_clear();
*
006DC:  RCALL  01E4
....................     display_start_screen();
006DE:  BRA    0572
....................     display_update();
006E0:  RCALL  028E
....................     while (TRUE) {
....................         controller_update_button_only();
006E2:  RCALL  06A0
....................         if (is_button_just_pressed()) {
006E4:  RCALL  06D2
006E6:  MOVF   01,F
006E8:  BZ    06F8
....................             display_clear();
006EA:  RCALL  01E4
....................             delay_ms(100);
006EC:  MOVLW  64
006EE:  MOVLB  4
006F0:  MOVWF  xC6
006F2:  MOVLB  0
006F4:  RCALL  0012
....................             break;
006F6:  BRA    0704
....................         }
....................         delay_ms(100);
006F8:  MOVLW  64
006FA:  MOVLB  4
006FC:  MOVWF  xC6
006FE:  MOVLB  0
00700:  RCALL  0012
00702:  BRA    06E2
....................     }
00704:  GOTO   16F8 (RETURN)
.................... }
.................... 
.................... void game_over_loop() {
*
0155A:  BRA    13BA
0155C:  MOVFF  01,4C2
....................     int hs = load_highscore();
....................     save_highscore(score, hs);
01560:  MOVFF  4A0,4C3
01564:  MOVFF  4C2,4C4
01568:  BRA    1410
....................     display_clear();
0156A:  CALL   0192
....................     display_gameover_screen(score, hs);
0156E:  MOVFF  4A0,4C3
01572:  MOVFF  4C2,4C4
01576:  BRA    1428
....................     display_update();
01578:  CALL   028E
....................     while (TRUE) {
....................         controller_update_button_only();
0157C:  CALL   06A0
....................         if (is_button_just_pressed()) {
01580:  CALL   06D2
01584:  MOVF   01,F
01586:  BZ    159A
....................             display_clear();
01588:  CALL   0192
....................             delay_ms(100);
0158C:  MOVLW  64
0158E:  MOVLB  4
01590:  MOVWF  xC6
01592:  MOVLB  0
01594:  CALL   0012
....................             break;
01598:  BRA    15A8
....................         }
....................         delay_ms(100);
0159A:  MOVLW  64
0159C:  MOVLB  4
0159E:  MOVWF  xC6
015A0:  MOVLB  0
015A2:  CALL   0012
015A6:  BRA    157C
....................     }
015A8:  GOTO   17E2 (RETURN)
.................... }
.................... 
.................... void main() {
015AC:  CLRF   FF8
015AE:  BCF    FD0.7
015B0:  MOVLW  70
015B2:  MOVWF  FD3
015B4:  BCF    F9B.6
015B6:  BCF    F9B.7
015B8:  BSF    F94.3
015BA:  BSF    F94.4
015BC:  BCF    FCB.0
015BE:  BCF    FCB.1
015C0:  BCF    FCB.3
015C2:  MOVLW  27
015C4:  MOVWF  FC8
015C6:  MOVLW  28
015C8:  MOVWF  FC6
015CA:  BSF    FC7.7
015CC:  BCF    FC7.6
015CE:  BCF    08.2
015D0:  BCF    08.3
015D2:  BCF    08.4
015D4:  BCF    08.5
015D6:  BRA    168C
015D8:  DATA 7A,04
015DA:  DATA 0D,1F
015DC:  DATA 11,1F
015DE:  DATA 00,1F
015E0:  DATA 00,1D
015E2:  DATA 15,17
015E4:  DATA 15,15
015E6:  DATA 1F,07
015E8:  DATA 04,1F
015EA:  DATA 17,15
015EC:  DATA 1D,1F
015EE:  DATA 15,1D
015F0:  DATA 01,01
015F2:  DATA 1F,1F
015F4:  DATA 15,1F
015F6:  DATA 17,15
015F8:  DATA 1F,61
015FA:  DATA 65,67
015FC:  DATA 68,6D
015FE:  DATA 6F,72
01600:  DATA 73,74
01602:  DATA 76,70
01604:  DATA 63,6C
01606:  DATA 69,6B
01608:  DATA 6E,64
0160A:  DATA 1E,05
0160C:  DATA 1F,1F
0160E:  DATA 15,15
01610:  DATA 0E,11
01612:  DATA 1D,1F
01614:  DATA 04,1F
01616:  DATA 1F,06
01618:  DATA 1F,0E
0161A:  DATA 11,0E
0161C:  DATA 1F,05
0161E:  DATA 1A,12
01620:  DATA 15,09
01622:  DATA 01,1F
01624:  DATA 01,07
01626:  DATA 18,07
01628:  DATA 1F,05
0162A:  DATA 02,0E
0162C:  DATA 11,11
0162E:  DATA 1F,10
01630:  DATA 10,00
01632:  DATA 1D,00
01634:  DATA 1F,04
01636:  DATA 1B,1F
01638:  DATA 01,1E
0163A:  DATA 1F,11
0163C:  DATA 0E,70
0163E:  DATA 8C,82
01640:  DATA 81,81
01642:  DATA 82,8C
01644:  DATA 70,18
01646:  DATA 24,42
01648:  DATA 81,42
0164A:  DATA 5A,24
0164C:  DATA C3,00
0164E:  DATA 00,00
01650:  DATA 7E,7E
01652:  DATA 00,00
01654:  DATA 00,04
01656:  DATA 04,99
01658:  DATA 70,50
0165A:  DATA 32,62
0165C:  DATA 05,C0
0165E:  DATA 00,03
01660:  DATA 04,A0
01662:  DATA 00,00
01664:  DATA 00,02
01666:  DATA 04,A2
01668:  DATA 00,00
0166A:  DATA 01,04
0166C:  DATA A3,00
0166E:  DATA 02,04
01670:  DATA A5,06
01672:  DATA 00,02
01674:  DATA 04,A5
01676:  DATA 06,00
01678:  DATA 12,44
0167A:  DATA B0,00
0167C:  DATA 05,4F
0167E:  DATA 38,00
01680:  DATA 03,0F
01682:  DATA 77,00
01684:  DATA 00,00
01686:  DATA 01,0F
01688:  DATA D3,70
0168A:  DATA 00,00
0168C:  MOVLW  00
0168E:  MOVWF  FF8
01690:  MOVLW  15
01692:  MOVWF  FF7
01694:  MOVLW  D8
01696:  MOVWF  FF6
01698:  TBLRD*+
0169A:  MOVF   FF5,W
0169C:  MOVWF  00
0169E:  XORLW  00
016A0:  BZ    16C8
016A2:  TBLRD*+
016A4:  MOVF   FF5,W
016A6:  MOVWF  01
016A8:  BTFSC  FE8.7
016AA:  BRA    16B6
016AC:  ANDLW  3F
016AE:  MOVWF  FEA
016B0:  TBLRD*+
016B2:  MOVFF  FF5,FE9
016B6:  BTFSC  01.6
016B8:  TBLRD*+
016BA:  BTFSS  01.6
016BC:  TBLRD*+
016BE:  MOVFF  FF5,FEE
016C2:  DCFSNZ 00,F
016C4:  BRA    1698
016C6:  BRA    16BA
016C8:  CLRF   FF8
....................     display_init();
016CA:  GOTO   0292
....................     controller_init();
016CE:  GOTO   02CC
....................     sem_init(&enemy_move_sem, 0);
016D2:  MOVLW  04
016D4:  MOVLB  4
016D6:  MOVWF  xC3
016D8:  MOVLW  A4
016DA:  MOVWF  xC2
016DC:  CLRF   xC4
016DE:  MOVLB  0
016E0:  GOTO   02D2
....................     mbox_init(&collision_mbox);
016E4:  MOVLW  04
016E6:  MOVLB  4
016E8:  MOVWF  xC3
016EA:  MOVLW  A7
016EC:  MOVWF  xC2
016EE:  MOVLB  0
016F0:  GOTO   02EE
.................... 
....................     while (TRUE) {
....................         start_screen_loop();
016F4:  GOTO   06DC
.................... 
....................         // Reset game state
....................         score = 0;
016F8:  MOVLB  4
016FA:  CLRF   xA0
....................         last_score = 0;
016FC:  CLRF   xA1
....................         enemy_move_interval = 2;
016FE:  MOVLW  02
01700:  MOVWF  xA5
....................         frame_counter = 0;
01702:  CLRF   xA6
....................         wave_spawned = 0;
01704:  CLRF   xA2
....................         game_over_flag = 0;
01706:  CLRF   xA3
....................         p.pos.x = 80; p.pos.y = 50;
01708:  MOVLW  50
0170A:  MOVWF  x9A
0170C:  MOVLW  32
0170E:  MOVWF  x9B
....................         b.is_active = 0;
01710:  CLRF   x9F
....................         display_clear();
01712:  MOVLB  0
01714:  CALL   0192
....................         spawn_enemy_wave();
01718:  CALL   0708
....................         display_draw_score(score);
0171C:  MOVFF  4A0,4C8
01720:  CALL   0968
.................... 
....................         // Setup scheduler tasks
....................         sched_init();
01724:  GOTO   0982
....................         sched_add_task(task_bullet);
01728:  MOVLW  0D
0172A:  MOVWF  03
0172C:  MOVLW  9A
0172E:  MOVLB  4
01730:  MOVWF  xC2
01732:  MOVFF  03,4C3
01736:  MOVFF  03,4C5
0173A:  MOVWF  xC4
0173C:  MOVLB  0
0173E:  CALL   09D6
....................         sched_add_task(task_player);
01742:  MOVLW  0C
01744:  MOVWF  03
01746:  MOVLW  C2
01748:  MOVLB  4
0174A:  MOVWF  xC2
0174C:  MOVFF  03,4C3
01750:  MOVFF  03,4C5
01754:  MOVWF  xC4
01756:  MOVLB  0
01758:  CALL   09D6
....................         sched_add_task(task_collision);
0175C:  MOVLW  0E
0175E:  MOVWF  03
01760:  MOVLW  5E
01762:  MOVLB  4
01764:  MOVWF  xC2
01766:  MOVFF  03,4C3
0176A:  MOVFF  03,4C5
0176E:  MOVWF  xC4
01770:  MOVLB  0
01772:  CALL   09D6
....................         sched_add_task(task_enemies);
01776:  MOVLW  10
01778:  MOVWF  03
0177A:  MOVLW  A8
0177C:  MOVLB  4
0177E:  MOVWF  xC2
01780:  MOVFF  03,4C3
01784:  MOVFF  03,4C5
01788:  MOVWF  xC4
0178A:  MOVLB  0
0178C:  CALL   09D6
....................         sched_add_task(task_score);
01790:  MOVLW  12
01792:  MOVWF  03
01794:  MOVLW  76
01796:  MOVLB  4
01798:  MOVWF  xC2
0179A:  MOVFF  03,4C3
0179E:  MOVFF  03,4C5
017A2:  MOVWF  xC4
017A4:  MOVLB  0
017A6:  CALL   09D6
....................         sched_add_task(task_display);
017AA:  MOVLW  0F
017AC:  MOVWF  03
017AE:  MOVLW  B2
017B0:  MOVLB  4
017B2:  MOVWF  xC2
017B4:  MOVFF  03,4C3
017B8:  MOVFF  03,4C5
017BC:  MOVWF  xC4
017BE:  MOVLB  0
017C0:  CALL   09D6
.................... 
....................         // Run until game_over_flag set
....................         while (!game_over_flag) {
017C4:  MOVLB  4
017C6:  MOVF   xA3,F
017C8:  BNZ   17DE
....................             sched_run_cycle(); // single cycle instead of forever
017CA:  MOVLB  0
017CC:  BRA    12BE
....................             delay_ms(100);
017CE:  MOVLW  64
017D0:  MOVLB  4
017D2:  MOVWF  xC6
017D4:  MOVLB  0
017D6:  CALL   0012
017DA:  BRA    17C4
017DC:  MOVLB  4
....................         }
.................... 
....................         game_over_loop();
017DE:  MOVLB  0
017E0:  BRA    155A
017E2:  BRA    16F4
....................     }
.................... }
.................... 
017E4:  SLEEP 
.................... #include <18F46K22.h>
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
*
00004:  MOVFF  FEC,FFA
00008:  MOVF   FED,F
0000A:  MOVFF  FEF,FE8
0000E:  MOVWF  FF9
00010:  RETURN 0
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... #include "simple_scheduler.h"
.................... #ifndef SIMPLE_SCHEDULER_H
.................... #define SIMPLE_SCHEDULER_H
.................... 
.................... typedef void (*task_fn_t)(void);
.................... 
.................... #define SCHED_MAX_TASKS 6
.................... 
.................... typedef struct{
....................     task_fn_t fn;
....................     unsigned char active; //0 if unused, 1 if active
.................... } Task;
.................... 
.................... typedef struct{
....................     unsigned char count;
.................... } Semaphore;
.................... 
.................... typedef struct{
....................     unsigned char full; //0 if empty, 1 if full
....................     unsigned char data[8]; //size can be changed
.................... } Mailbox;
.................... 
.................... /*Scheduler API*/
.................... void sched_init(void);
.................... int sched_add_task(task_fn_t fn);
.................... void sched_run_cycle(void); //run one cycle
.................... void sched_run_forever(unsigned int cycle_delay_ms);
.................... 
.................... void sched_yield(void);
.................... 
.................... /*Semaphore API*/
.................... void sem_init(Semaphore *s, unsigned char init);
.................... unsigned char sem_trywait(Semaphore *s);
.................... void sem_wait(Semaphore *s);    /* blocks co-operatively: sets count-- if >0 else returns 0 so task can yield */
.................... void sem_signal(Semaphore *s);
.................... 
.................... /*mailbox*/
.................... void mbox_init(Mailbox *m);
.................... unsigned char mbox_send(Mailbox *m, int8 buf[], int8 size);
.................... unsigned char mbox_receive(Mailbox *m, int8 out[], int8 size);
.................... 
.................... #endif
.................... 
.................... 
.................... static Task task_list[SCHED_MAX_TASKS];
.................... 
.................... void sched_init(void){
....................     unsigned char i;
.................... 
....................     for (i = 0; i < SCHED_MAX_TASKS; i++){
*
00982:  MOVLB  4
00984:  CLRF   xC2
00986:  MOVF   xC2,W
00988:  SUBLW  05
0098A:  BNC   09D0
....................         task_list[i].fn = 0;
0098C:  MOVF   xC2,W
0098E:  MULLW  03
00990:  MOVF   FF3,W
00992:  CLRF   xC4
00994:  MOVWF  xC3
00996:  MOVLW  B0
00998:  ADDWF  xC3,W
0099A:  MOVWF  FE9
0099C:  MOVLW  04
0099E:  ADDWFC xC4,W
009A0:  MOVWF  FEA
009A2:  CLRF   FEC
009A4:  MOVF   FED,F
009A6:  CLRF   FEF
....................         task_list[i].active = 0;
009A8:  MOVF   xC2,W
009AA:  MULLW  03
009AC:  MOVF   FF3,W
009AE:  CLRF   xC4
009B0:  MOVWF  xC3
009B2:  MOVLW  02
009B4:  ADDWF  xC3,W
009B6:  MOVWF  01
009B8:  MOVLW  00
009BA:  ADDWFC xC4,W
009BC:  MOVWF  03
009BE:  MOVF   01,W
009C0:  ADDLW  B0
009C2:  MOVWF  FE9
009C4:  MOVLW  04
009C6:  ADDWFC 03,W
009C8:  MOVWF  FEA
009CA:  CLRF   FEF
009CC:  INCF   xC2,F
009CE:  BRA    0986
....................     }
009D0:  MOVLB  0
009D2:  GOTO   1728 (RETURN)
.................... }
.................... 
.................... int sched_add_task(task_fn_t fn){
....................     unsigned char i;
....................     for (i = 0; i < SCHED_MAX_TASKS; i++){
009D6:  MOVLB  4
009D8:  CLRF   xC6
009DA:  MOVF   xC6,W
009DC:  SUBLW  05
009DE:  BNC   0A56
....................         if (task_list[i].active == 0){
009E0:  MOVF   xC6,W
009E2:  MULLW  03
009E4:  MOVF   FF3,W
009E6:  CLRF   xC8
009E8:  MOVWF  xC7
009EA:  MOVLW  02
009EC:  ADDWF  xC7,W
009EE:  MOVWF  01
009F0:  MOVLW  00
009F2:  ADDWFC xC8,W
009F4:  MOVWF  03
009F6:  MOVF   01,W
009F8:  ADDLW  B0
009FA:  MOVWF  FE9
009FC:  MOVLW  04
009FE:  ADDWFC 03,W
00A00:  MOVWF  FEA
00A02:  MOVF   FEF,F
00A04:  BNZ   0A52
....................             task_list[i].fn = fn;
00A06:  MOVF   xC6,W
00A08:  MULLW  03
00A0A:  MOVF   FF3,W
00A0C:  CLRF   xC8
00A0E:  MOVWF  xC7
00A10:  MOVLW  B0
00A12:  ADDWF  xC7,W
00A14:  MOVWF  FE9
00A16:  MOVLW  04
00A18:  ADDWFC xC8,W
00A1A:  MOVWF  FEA
00A1C:  MOVFF  4C5,FEC
00A20:  MOVF   FED,F
00A22:  MOVFF  4C4,FEF
....................             task_list[i].active = 1;
00A26:  MOVF   xC6,W
00A28:  MULLW  03
00A2A:  MOVF   FF3,W
00A2C:  CLRF   xC8
00A2E:  MOVWF  xC7
00A30:  MOVLW  02
00A32:  ADDWF  xC7,W
00A34:  MOVWF  01
00A36:  MOVLW  00
00A38:  ADDWFC xC8,W
00A3A:  MOVWF  03
00A3C:  MOVF   01,W
00A3E:  ADDLW  B0
00A40:  MOVWF  FE9
00A42:  MOVLW  04
00A44:  ADDWFC 03,W
00A46:  MOVWF  FEA
00A48:  MOVLW  01
00A4A:  MOVWF  FEF
....................             return i;
00A4C:  MOVFF  4C6,01
00A50:  BRA    0A5A
....................         }
00A52:  INCF   xC6,F
00A54:  BRA    09DA
....................     }
....................     return -1; //no space in the list
00A56:  MOVLW  FF
00A58:  MOVWF  01
00A5A:  MOVLB  0
00A5C:  RETURN 0
.................... }
.................... 
.................... void sched_run_cycle(void){
....................     unsigned char i;
....................     for (i = 0; i < SCHED_MAX_TASKS; i++){
*
012BE:  MOVLB  4
012C0:  CLRF   xC2
012C2:  MOVF   xC2,W
012C4:  SUBLW  05
012C6:  BNC   1344
....................         if (task_list[i].active && task_list[i].fn != 0){
012C8:  MOVF   xC2,W
012CA:  MULLW  03
012CC:  MOVF   FF3,W
012CE:  CLRF   xC4
012D0:  MOVWF  xC3
012D2:  MOVLW  02
012D4:  ADDWF  xC3,W
012D6:  MOVWF  01
012D8:  MOVLW  00
012DA:  ADDWFC xC4,W
012DC:  MOVWF  03
012DE:  MOVF   01,W
012E0:  ADDLW  B0
012E2:  MOVWF  FE9
012E4:  MOVLW  04
012E6:  ADDWFC 03,W
012E8:  MOVWF  FEA
012EA:  MOVF   FEF,F
012EC:  BZ    1340
012EE:  MOVF   xC2,W
012F0:  MULLW  03
012F2:  MOVF   FF3,W
012F4:  CLRF   xC4
012F6:  MOVWF  xC3
012F8:  MOVLW  B0
012FA:  ADDWF  xC3,W
012FC:  MOVWF  FE9
012FE:  MOVLW  04
01300:  ADDWFC xC4,W
01302:  MOVWF  FEA
01304:  MOVFF  FEC,4C6
01308:  MOVF   FED,F
0130A:  MOVFF  FEF,4C5
0130E:  MOVF   xC5,F
01310:  BNZ   1316
01312:  MOVF   xC6,F
01314:  BZ    1340
....................             task_list[i].fn();
01316:  MOVF   xC2,W
01318:  MULLW  03
0131A:  MOVF   FF3,W
0131C:  CLRF   xC4
0131E:  MOVWF  xC3
01320:  MOVLW  B0
01322:  ADDWF  xC3,W
01324:  MOVWF  01
01326:  MOVLW  04
01328:  ADDWFC xC4,W
0132A:  MOVWF  03
0132C:  MOVFF  01,4C5
01330:  MOVWF  xC6
01332:  MOVWF  FEA
01334:  MOVFF  01,FE9
01338:  MOVLB  0
0133A:  CALL   0004
0133E:  MOVLB  4
....................         }
01340:  INCF   xC2,F
01342:  BRA    12C2
....................     }
01344:  MOVLB  0
01346:  GOTO   17CE (RETURN)
.................... }
.................... 
.................... void sched_run_forever(unsigned int cycle_delay_ms){
....................     while (1){
....................         sched_run_cycle();
....................         delay_ms(cycle_delay_ms);
....................     }
.................... }
.................... 
.................... // For cooperative tasks that want to yield voluntarily
.................... void sched_yield(void) {
....................     // In a cooperative scheduler, yield just returns control
....................     // to sched_run_cycle by exiting the task function.
....................     // Nothing else needed here.
.................... }
.................... 
.................... 
.................... 
.................... //SEMAPHORES
.................... void sem_init(Semaphore *s, unsigned char init){
....................     if (s != 0){
*
002D2:  MOVLB  4
002D4:  MOVF   xC2,F
002D6:  BNZ   02DC
002D8:  MOVF   xC3,F
002DA:  BZ    02E8
....................         s->count = init;
002DC:  MOVFF  4C2,FE9
002E0:  MOVFF  4C3,FEA
002E4:  MOVFF  4C4,FEF
....................     }
002E8:  MOVLB  0
002EA:  GOTO   16E4 (RETURN)
.................... }
.................... 
.................... unsigned char sem_trywait(Semaphore *s){
....................     if (s == 0) return 0;
*
00FDA:  MOVLB  4
00FDC:  MOVF   xCA,F
00FDE:  BNZ   0FEA
00FE0:  MOVF   xCB,F
00FE2:  BNZ   0FEA
00FE4:  MOVLW  00
00FE6:  MOVWF  01
00FE8:  BRA    100A
....................     if (s->count > 0){
00FEA:  MOVFF  4CA,FE9
00FEE:  MOVFF  4CB,FEA
00FF2:  MOVF   FEF,F
00FF4:  BZ    1006
....................         s->count--;
00FF6:  MOVFF  4CA,FE9
00FFA:  MOVFF  4CB,FEA
00FFE:  DECF   FEF,F
....................         return 1;
01000:  MOVLW  01
01002:  MOVWF  01
01004:  BRA    100A
....................     }
....................     return 0;
01006:  MOVLW  00
01008:  MOVWF  01
0100A:  MOVLB  0
0100C:  GOTO   1112 (RETURN)
.................... }
.................... 
.................... void sem_wait(Semaphore *s){
....................     if (s == 0) return;
....................     while (s->count == 0){
....................         sched_yield();
....................     }
....................     s->count--;
.................... }
.................... 
.................... void sem_signal(Semaphore *s){
....................     if (s != 0){
*
00F98:  MOVLB  4
00F9A:  MOVF   xC7,F
00F9C:  BNZ   0FA2
00F9E:  MOVF   xC8,F
00FA0:  BZ    0FAC
....................         s->count++;
00FA2:  MOVFF  4C7,FE9
00FA6:  MOVFF  4C8,FEA
00FAA:  INCF   FEF,F
....................     }
00FAC:  MOVLB  0
00FAE:  GOTO   0FD8 (RETURN)
.................... }
.................... 
.................... //MAILBOX
.................... void mbox_init(Mailbox *m){
....................     unsigned char i;
....................     if (m != 0){
*
002EE:  MOVLB  4
002F0:  MOVF   xC2,F
002F2:  BNZ   02F8
002F4:  MOVF   xC3,F
002F6:  BZ    031E
....................         m->full = 0;
002F8:  MOVFF  4C2,FE9
002FC:  MOVFF  4C3,FEA
00300:  CLRF   FEF
....................         for (i = 0; i < sizeof(m->data); i++){
00302:  CLRF   xC4
00304:  MOVF   xC4,W
00306:  SUBLW  07
00308:  BNC   031E
....................             m->data[i] = 0;
0030A:  MOVLW  01
0030C:  ADDWF  xC4,W
0030E:  ADDWF  xC2,W
00310:  MOVWF  FE9
00312:  MOVLW  00
00314:  ADDWFC xC3,W
00316:  MOVWF  FEA
00318:  CLRF   FEF
0031A:  INCF   xC4,F
0031C:  BRA    0304
....................         }
....................     }
0031E:  MOVLB  0
00320:  GOTO   16F4 (RETURN)
.................... }
.................... 
.................... unsigned char mbox_send(Mailbox *m, int8 buf[], int8 size) {
....................     if (m->full || size > sizeof(m->data)) {
*
00DFA:  MOVLB  4
00DFC:  MOVFF  4C9,FE9
00E00:  MOVFF  4CA,FEA
00E04:  MOVF   FEF,F
00E06:  BNZ   0E0E
00E08:  MOVF   xCD,W
00E0A:  SUBLW  08
00E0C:  BC    0E14
....................         return 0; // fail
00E0E:  MOVLW  00
00E10:  MOVWF  01
00E12:  BRA    0E58
....................     }
....................     for (unsigned char i = 0; i < size; i++) {
00E14:  CLRF   xCE
00E16:  MOVF   xCD,W
00E18:  SUBWF  xCE,W
00E1A:  BC    0E4A
....................         m->data[i] = buf[i];
00E1C:  MOVLW  01
00E1E:  ADDWF  xCE,W
00E20:  ADDWF  xC9,W
00E22:  MOVWF  01
00E24:  MOVLW  00
00E26:  ADDWFC xCA,W
00E28:  MOVWF  03
00E2A:  MOVF   xCE,W
00E2C:  ADDWF  xCB,W
00E2E:  MOVWF  FE9
00E30:  MOVLW  00
00E32:  ADDWFC xCC,W
00E34:  MOVWF  FEA
00E36:  MOVFF  FEF,4D1
00E3A:  MOVFF  03,FEA
00E3E:  MOVFF  01,FE9
00E42:  MOVFF  4D1,FEF
00E46:  INCF   xCE,F
00E48:  BRA    0E16
....................     }
....................     m->full = 1;
00E4A:  MOVFF  4C9,FE9
00E4E:  MOVFF  4CA,FEA
00E52:  MOVLW  01
00E54:  MOVWF  FEF
....................     return 1; // success
00E56:  MOVWF  01
00E58:  MOVLB  0
00E5A:  GOTO   0F16 (RETURN)
.................... }
.................... 
.................... unsigned char mbox_receive(Mailbox *m, int8 out[], int8 size) {
....................     if (!m->full || size > sizeof(m->data)) {
*
011F0:  MOVLB  4
011F2:  MOVFF  4C8,FE9
011F6:  MOVFF  4C9,FEA
011FA:  MOVF   FEF,F
011FC:  BZ    1204
011FE:  MOVF   xCC,W
01200:  SUBLW  08
01202:  BC    120A
....................         return 0; // fail
01204:  MOVLW  00
01206:  MOVWF  01
01208:  BRA    124E
....................     }
....................     for (unsigned char i = 0; i < size; i++) {
0120A:  CLRF   xCD
0120C:  MOVF   xCC,W
0120E:  SUBWF  xCD,W
01210:  BC    1240
....................         out[i] = m->data[i];
01212:  MOVF   xCD,W
01214:  ADDWF  xCA,W
01216:  MOVWF  01
01218:  MOVLW  00
0121A:  ADDWFC xCB,W
0121C:  MOVWF  03
0121E:  MOVLW  01
01220:  ADDWF  xCD,W
01222:  ADDWF  xC8,W
01224:  MOVWF  FE9
01226:  MOVLW  00
01228:  ADDWFC xC9,W
0122A:  MOVWF  FEA
0122C:  MOVFF  FEF,4D0
01230:  MOVFF  03,FEA
01234:  MOVFF  01,FE9
01238:  MOVFF  4D0,FEF
0123C:  INCF   xCD,F
0123E:  BRA    120C
....................     }
....................     m->full = 0;
01240:  MOVFF  4C8,FE9
01244:  MOVFF  4C9,FEA
01248:  CLRF   FEF
....................     return 1; // success
0124A:  MOVLW  01
0124C:  MOVWF  01
0124E:  MOVLB  0
01250:  GOTO   1290 (RETURN)
.................... }
.................... 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 P2BD2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
