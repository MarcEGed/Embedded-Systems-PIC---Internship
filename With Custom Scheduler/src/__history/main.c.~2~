#include <18F46K22.h>
#fuses INTRC_IO, NOWDT, NOLVP, NOPROTECT
#use delay(clock=16MHz)
#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)

#include "API/display.h"
#include "API/controller.h"
#include "API/memory.h"
#include "Utilities/entities.h"
#include "Utilities/vec2.h"

#include "simple_scheduler.h"

#define ENEMIES_PER_WAVE     6
#define ENEMY_X_LIMIT        80

Enemy enemies[ENEMIES_PER_WAVE];
Player p = {'p', {80, 50}};
Bullet b = {'b', {0, 0}, 0};
int score = 0;
int last_score = 0;
int enemy_move_interval = 2;
int frame_counter = 0;
int wave_spawned = 0;
int game_over_flag = 0;

// Spawns a wave of enemies in their starting positions
void spawn_enemy_wave() {
    Enemy new_wave[ENEMIES_PER_WAVE] = {
        { 'e',  {5,  5}, 1, 0, 1 },  // enemies[0]
        { 'e',  {5, 25}, 1, 0, 1 },  // enemies[1]
        { 'e',  {5, 45}, 1, 0, 1 },  // enemies[2]
        { 'e', {30,  5}, 1, 0, 1 },  // enemies[3]
        { 'e', {30, 25}, 1, 0, 1 },  // enemies[4]
        { 'e', {30, 45}, 1, 0, 1 }   // enemies[5]
    };

    for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
        enemies[i] = new_wave[i];
        display_draw_enemy(enemies[i].pos);
    }
}

void task_player(void){
    display_clear_entity(p.pos, 8, 8);
    controller_update(&p.pos);
    controller_shoot(p, &b);
    p.pos = display_move_player(p.pos);
}

void task_bullet(void){
    if (b.is_active){
        b = display_move_bullet(b);
    }
}

void task_collision(void){
    for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
        if (check_collisionBE(b, enemies[i]) && b.is_active && enemies[i].is_active) {
            b.is_active = 0;
            enemies[i].is_active = 0;
            display_clear_entity(enemies[i].pos, 8, 8);
            display_clear_entity(b.pos, 8, 8);
            score++;
            break;
        }
    }
}

void task_enemies(void) {
    int active_count = 0;
    for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
        if (enemies[i].is_active) {
            active_count++;
        }
    }
    if (active_count == 0 && !wave_spawned) {
        if (enemy_move_interval > 1) {
            enemy_move_interval--;
        }
        spawn_enemy_wave();
        wave_spawned = 1;
    }
    if (wave_spawned && active_count > 0) {
        wave_spawned = 0;
    }

    if (frame_counter % enemy_move_interval == 0) {
        for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
            if (enemies[i].is_active) {
                enemies[i] = display_move_enemy(enemies[i]);
                if (enemies[i].pos.x >= ENEMY_X_LIMIT) {
                    game_over_flag = 1; // signal to stop scheduler
                }
            }
        }
    }
}

void task_score(void) {
    if (score != last_score) {
        display_clear_score();
        display_draw_score(score);
        last_score = score;
    }
}

void task_display(void) {
    display_update();
    frame_counter++;
}

void start_screen_loop() {
    display_clear();
    display_start_screen();
    display_update();
    while (TRUE) {
        controller_update_button_only();
        if (is_button_just_pressed()) {
            display_clear();
            delay_ms(100);
            break;
        }
        delay_ms(100);
    }
}

void game_over_loop() {
    int hs = load_highscore();
    save_highscore(score, hs);
    display_clear();
    display_gameover_screen(score, hs);
    display_update();
    while (TRUE) {
        controller_update_button_only();
        if (is_button_just_pressed()) {
            display_clear();
            delay_ms(100);
            break;
        }
        delay_ms(100);
    }
}

void main() {
    display_init();
    controller_init();

    while (TRUE) {
        start_screen_loop();

        // Reset game state
        score = 0;
        last_score = 0;
        enemy_move_interval = 2;
        frame_counter = 0;
        wave_spawned = 0;
        game_over_flag = 0;
        p.pos.x = 80; p.pos.y = 50;
        b.is_active = 0;
        display_clear();
        spawn_enemy_wave();
        display_draw_score(score);

        // Setup scheduler tasks
        sched_init();
        sched_add_task(task_player);
        sched_add_task(task_bullet);
        sched_add_task(task_collision);
        sched_add_task(task_enemies);
        sched_add_task(task_score);
        sched_add_task(task_display);

        // Run until game_over_flag set
        while (!game_over_flag) {
            sched_run_once(); // single cycle instead of forever
            delay_ms(100);
        }

        game_over_loop();
    }
}
