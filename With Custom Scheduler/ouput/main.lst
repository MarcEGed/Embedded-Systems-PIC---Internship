CCS PCH C Compiler, Version 5.120, 4205               12-Aug-25 16:28

               Filename:   ..\ouput\main.lst

               ROM used:   6114 bytes (9%)
                           Largest free fragment is 59422
               RAM used:   1222 (31%) at main() level
                           1299 (33%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   15BE
.................... #import(file="..\ouput\eeprom_24LC512.o")
.................... /*
.................... /*
....................     eeprom_24LC512.c - Driver for 24LC512 I2C EEPROM (written for PIC18F46K22)
....................     Implements sinngle byte read/write to a fixed address (STATE_ADDR)
....................     Uses pin C4 (for SDA) and pin C3 (for SDL)
....................     Needs CCS I2C library
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #fuses INTRC_IO, NOWDT, NOLVP, NOPROTECT
.................... #use delay(clock=16M)
*
00012:  MOVLW  04
00014:  MOVWF  FEA
00016:  MOVLW  C8
00018:  MOVWF  FE9
0001A:  MOVF   FEF,W
0001C:  BZ    003A
0001E:  MOVLW  05
00020:  MOVWF  01
00022:  CLRF   00
00024:  DECFSZ 00,F
00026:  BRA    0024
00028:  DECFSZ 01,F
0002A:  BRA    0022
0002C:  MOVLW  2E
0002E:  MOVWF  00
00030:  DECFSZ 00,F
00032:  BRA    0030
00034:  BRA    0036
00036:  DECFSZ FEF,F
00038:  BRA    001E
0003A:  RETURN 0
.................... #use i2c(Master, SDA=PIN_C4, SCL=PIN_C3, FAST=100000)
0003C:  BCF    FC6.7
0003E:  BCF    F9E.3
00040:  MOVFF  4CD,FC9
00044:  MOVLW  02
00046:  BTFSC  FC6.7
00048:  BRA    0054
0004A:  BTFSC  FC7.2
0004C:  BRA    004A
0004E:  MOVLW  00
00050:  BTFSC  FC5.6
00052:  MOVLW  01
00054:  MOVWF  01
00056:  RETURN 0
*
0135C:  BCF    FC6.6
0135E:  BSF    FC5.3
01360:  BTFSC  FC5.3
01362:  BRA    1360
01364:  BTFSC  00.0
01366:  BCF    FC5.5
01368:  BTFSS  00.0
0136A:  BSF    FC5.5
0136C:  BSF    FC5.4
0136E:  BTFSC  FC5.4
01370:  BRA    136E
01372:  MOVFF  FC9,01
01376:  GOTO   13B6 (RETURN)
.................... 
.................... #include "eeprom_24LC512.h"
.................... //eeprom_24LC512.h
.................... 
.................... #ifndef EEPROM_24LC512
.................... #define EEPROM_24LC512
.................... 
.................... #define EEPROM_ADDR_WRITE  0xA0
.................... #define EEPROM_ADDR_READ   0xA1
.................... 
.................... #define STATE_ADDR 0x0000
.................... 
.................... void eeprom_write_byte(BYTE data);
.................... BYTE eeprom_read_byte();
.................... 
.................... #endif
.................... 
.................... 
.................... void eeprom_write_byte(BYTE data) {
....................     //Writes byte to STATE_ADDR
....................     i2c_start();
*
013DE:  BSF    FC5.0
013E0:  BTFSC  FC5.0
013E2:  BRA    13E0
....................     i2c_write(EEPROM_ADDR_WRITE);
013E4:  MOVLW  A0
013E6:  MOVLB  4
013E8:  MOVWF  xCD
013EA:  MOVLB  0
013EC:  CALL   003C
....................     i2c_write(STATE_ADDR >> 8);     //upper bits
013F0:  MOVLB  4
013F2:  CLRF   xCD
013F4:  MOVLB  0
013F6:  CALL   003C
....................     i2c_write(STATE_ADDR & 0xFF);   //lower bits
013FA:  MOVLB  4
013FC:  CLRF   xCD
013FE:  MOVLB  0
01400:  CALL   003C
....................     i2c_write(data);
01404:  MOVFF  4C7,4CD
01408:  CALL   003C
....................     i2c_stop();
0140C:  BSF    FC5.2
0140E:  BTFSC  FC5.2
01410:  BRA    140E
....................     delay_ms(5);
01412:  MOVLW  05
01414:  MOVLB  4
01416:  MOVWF  xC8
01418:  MOVLB  0
0141A:  CALL   0012
0141E:  GOTO   1432 (RETURN)
.................... }
.................... 
.................... BYTE eeprom_read_byte() {
....................     //Reads byte from STATE_ADDR
....................     BYTE data;
....................     i2c_start();
*
0137A:  BSF    FC5.0
0137C:  BTFSC  FC5.0
0137E:  BRA    137C
....................     i2c_write(EEPROM_ADDR_WRITE);
01380:  MOVLW  A0
01382:  MOVLB  4
01384:  MOVWF  xCD
01386:  MOVLB  0
01388:  CALL   003C
....................     i2c_write(STATE_ADDR >> 8);     //upper bits
0138C:  MOVLB  4
0138E:  CLRF   xCD
01390:  MOVLB  0
01392:  CALL   003C
....................     i2c_write(STATE_ADDR & 0xFF);   //lower bits
01396:  MOVLB  4
01398:  CLRF   xCD
0139A:  MOVLB  0
0139C:  CALL   003C
....................     i2c_start();
013A0:  BSF    FC5.1
013A2:  BTFSC  FC5.1
013A4:  BRA    13A2
....................     i2c_write(EEPROM_ADDR_READ);
013A6:  MOVLW  A1
013A8:  MOVLB  4
013AA:  MOVWF  xCD
013AC:  MOVLB  0
013AE:  CALL   003C
....................     data = i2c_read(0);
013B2:  CLRF   00
013B4:  BRA    135C
013B6:  MOVFF  01,4C6
....................     i2c_stop();
013BA:  BSF    FC5.2
013BC:  BTFSC  FC5.2
013BE:  BRA    13BC
....................     return data;
013C0:  MOVLB  4
013C2:  MOVFF  4C6,01
013C6:  MOVLB  0
013C8:  GOTO   13CE (RETURN)
.................... }
.................... 
.................... /*
.................... /*
....................     joystick.c - Driver for generic joystick module (written for PIC18F46K22)
....................     Reads X/Y axes via ADC channels RA2 for X and RA1 for Y
....................     Reads SW (switch) state via digital input PIN_B0
....................     Needs ADC modules and digital I/O ports to function
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "joystick.h"
.................... //joystick.h
.................... 
.................... #ifndef JOYSTICK_H
.................... #define JOYSTICK_H
.................... 
.................... void joystick_init();
.................... 
.................... int get_Joystick_X();
.................... int get_Joystick_Y();
.................... int1 get_Joystick_SW();
.................... 
.................... #endif
.................... 
.................... 
.................... #define VRX_PIN 2   //RA2
.................... #define VRY_PIN 1   //RA1
.................... #define SW_PIN  PIN_B0
.................... 
.................... void joystick_init(){
....................     //initializes all ports needed
....................     setup_adc_ports(sAN1 | sAN2);
*
0029C:  MOVF   FC1,W
0029E:  ANDLW  F0
002A0:  MOVWF  FC1
002A2:  MOVLW  06
002A4:  MOVLB  F
002A6:  MOVWF  x38
002A8:  MOVLW  00
002AA:  MOVWF  x3C
002AC:  MOVWF  x39
002AE:  MOVWF  x3A
002B0:  MOVWF  x3B
....................     setup_adc(ADC_CLOCK_INTERNAL);
002B2:  MOVF   FC0,W
002B4:  ANDLW  C0
002B6:  IORLW  07
002B8:  MOVWF  FC0
002BA:  BCF    FC0.7
002BC:  BSF    FC2.0
.................... 
....................     port_b_pullups(TRUE);
002BE:  MOVLW  01
002C0:  MOVWF  F61
002C2:  BCF    FF1.7
....................     input(SW_PIN);
002C4:  BSF    F93.0
002C6:  MOVLB  0
002C8:  GOTO   02CE (RETURN)
.................... }
.................... 
.................... int get_Joystick_X(){
....................     //get X adc value 
....................     set_adc_channel(VRX_PIN);
*
00AD2:  MOVLW  08
00AD4:  MOVWF  01
00AD6:  MOVF   FC2,W
00AD8:  ANDLW  83
00ADA:  IORWF  01,W
00ADC:  MOVWF  FC2
....................     delay_us(10);
00ADE:  MOVLW  0D
00AE0:  MOVWF  00
00AE2:  DECFSZ 00,F
00AE4:  BRA    0AE2
....................     return read_adc();
00AE6:  BSF    FC2.1
00AE8:  BTFSC  FC2.1
00AEA:  BRA    0AE8
00AEC:  MOVFF  FC4,01
00AF0:  GOTO   0B18 (RETURN)
.................... }
.................... 
.................... int get_Joystick_Y(){
....................     //get Y adc value
....................     set_adc_channel(VRY_PIN);
00AF4:  MOVLW  04
00AF6:  MOVWF  01
00AF8:  MOVF   FC2,W
00AFA:  ANDLW  83
00AFC:  IORWF  01,W
00AFE:  MOVWF  FC2
....................     delay_us(10);
00B00:  MOVLW  0D
00B02:  MOVWF  00
00B04:  DECFSZ 00,F
00B06:  BRA    0B04
....................     return read_adc();
00B08:  BSF    FC2.1
00B0A:  BTFSC  FC2.1
00B0C:  BRA    0B0A
00B0E:  MOVFF  FC4,01
00B12:  GOTO   0B1E (RETURN)
.................... }
.................... 
.................... int1 get_Joystick_SW(){
....................     //get switch state
....................     return input(SW_PIN);
*
00692:  BSF    F93.0
00694:  MOVLW  00
00696:  BTFSC  F81.0
00698:  MOVLW  01
0069A:  MOVWF  01
0069C:  RETURN 0
.................... }
.................... 
.................... 
.................... /*
.................... /*
....................    sh1106.c - Driver for sh1106 OLED screen module (written for PIC18F46K22)
....................    Controls OLED via I2C using pins C4 (SDA) and C3 (SDL)
....................    Provides functions to initialize, update screen, draw pixels and clear buffer
....................    Needs CCS I2C library
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
*
00170:  MOVLB  5
00172:  MOVF   x0E,W
00174:  MULWF  x10
00176:  MOVFF  FF3,01
0017A:  MOVFF  FF4,00
0017E:  MULWF  x11
00180:  MOVF   FF3,W
00182:  ADDWF  00,F
00184:  MOVF   x0F,W
00186:  MULWF  x10
00188:  MOVF   FF3,W
0018A:  ADDWFC 00,W
0018C:  MOVWF  02
0018E:  MOVLB  0
00190:  RETURN 0
.................... 
.................... #list
.................... 
.................... #fuses INTRC_IO, NOWDT, NOLVP, NOPROTECT
.................... #use delay(clock=16M)
.................... #use i2c(Master, SDA=PIN_C4, SCL=PIN_C3, FAST=100000)
.................... 
.................... #include "sh1106.h"
.................... //sh1106.h
.................... #ifndef SH1106_H
.................... #define SH1106_H
.................... 
.................... #define SH1106_ADDR 0x78
.................... #define WIDTH 128
.................... #define HEIGHT 64
.................... 
.................... extern BYTE buffer[8][128];
.................... 
.................... void sh1106_cmd(unsigned char cmd);
.................... void sh1106_data(unsigned char data);
.................... void sh1106_init();
.................... void sh1106_update_screen();
.................... void sh1106_draw_pixel(int x, int y, int color);
.................... void sh1106_clear_buffer();
.................... 
.................... #endif
.................... 
.................... 
.................... BYTE buffer[8][128];
.................... 
.................... void sh1106_cmd(unsigned char cmd) {
....................    //send a command to the screen
....................    i2c_start();
*
00058:  BSF    FC5.0
0005A:  BTFSC  FC5.0
0005C:  BRA    005A
....................    i2c_write(SH1106_ADDR);
0005E:  MOVLW  78
00060:  MOVLB  4
00062:  MOVWF  xCD
00064:  MOVLB  0
00066:  RCALL  003C
....................    i2c_write(0x00);
00068:  MOVLB  4
0006A:  CLRF   xCD
0006C:  MOVLB  0
0006E:  RCALL  003C
....................    i2c_write(cmd);
00070:  MOVFF  4CC,4CD
00074:  RCALL  003C
....................    i2c_stop();
00076:  BSF    FC5.2
00078:  BTFSC  FC5.2
0007A:  BRA    0078
0007C:  RETURN 0
.................... }
.................... 
.................... void sh1106_data(unsigned char data) {
....................    //send data to the screen
....................    i2c_start();
*
001E8:  BSF    FC5.0
001EA:  BTFSC  FC5.0
001EC:  BRA    01EA
....................    i2c_write(SH1106_ADDR);
001EE:  MOVLW  78
001F0:  MOVLB  4
001F2:  MOVWF  xCD
001F4:  MOVLB  0
001F6:  RCALL  003C
....................    i2c_write(0x40);
001F8:  MOVLW  40
001FA:  MOVLB  4
001FC:  MOVWF  xCD
001FE:  MOVLB  0
00200:  RCALL  003C
....................    i2c_write(data);
00202:  MOVFF  4CC,4CD
00206:  RCALL  003C
....................    i2c_stop();
00208:  BSF    FC5.2
0020A:  BTFSC  FC5.2
0020C:  BRA    020A
0020E:  GOTO   027E (RETURN)
.................... }
.................... 
.................... void sh1106_init() {
....................    //initializes the screen
....................    delay_ms(100);                       //wait for power
*
0007E:  MOVLW  64
00080:  MOVLB  4
00082:  MOVWF  xC8
00084:  MOVLB  0
00086:  RCALL  0012
.................... 
....................    sh1106_cmd(0xAE);                    //display off
00088:  MOVLW  AE
0008A:  MOVLB  4
0008C:  MOVWF  xCC
0008E:  MOVLB  0
00090:  RCALL  0058
....................    sh1106_cmd(0xD5); sh1106_cmd(0x80);  //set clock
00092:  MOVLW  D5
00094:  MOVLB  4
00096:  MOVWF  xCC
00098:  MOVLB  0
0009A:  RCALL  0058
0009C:  MOVLW  80
0009E:  MOVLB  4
000A0:  MOVWF  xCC
000A2:  MOVLB  0
000A4:  RCALL  0058
....................    sh1106_cmd(0xA8); sh1106_cmd(0x3F);  //multiplex 64
000A6:  MOVLW  A8
000A8:  MOVLB  4
000AA:  MOVWF  xCC
000AC:  MOVLB  0
000AE:  RCALL  0058
000B0:  MOVLW  3F
000B2:  MOVLB  4
000B4:  MOVWF  xCC
000B6:  MOVLB  0
000B8:  RCALL  0058
....................    sh1106_cmd(0xD3); sh1106_cmd(0x00);  //no offset
000BA:  MOVLW  D3
000BC:  MOVLB  4
000BE:  MOVWF  xCC
000C0:  MOVLB  0
000C2:  RCALL  0058
000C4:  MOVLB  4
000C6:  CLRF   xCC
000C8:  MOVLB  0
000CA:  RCALL  0058
....................    sh1106_cmd(0x40);                    //start line0
000CC:  MOVLW  40
000CE:  MOVLB  4
000D0:  MOVWF  xCC
000D2:  MOVLB  0
000D4:  RCALL  0058
.................... 
....................    sh1106_cmd(0xAD); sh1106_cmd(0x8B);  //charge pump
000D6:  MOVLW  AD
000D8:  MOVLB  4
000DA:  MOVWF  xCC
000DC:  MOVLB  0
000DE:  RCALL  0058
000E0:  MOVLW  8B
000E2:  MOVLB  4
000E4:  MOVWF  xCC
000E6:  MOVLB  0
000E8:  RCALL  0058
....................    sh1106_cmd(0xA1);                    //mirror x
000EA:  MOVLW  A1
000EC:  MOVLB  4
000EE:  MOVWF  xCC
000F0:  MOVLB  0
000F2:  RCALL  0058
....................    sh1106_cmd(0xC8);                    //mirror y
000F4:  MOVLW  C8
000F6:  MOVLB  4
000F8:  MOVWF  xCC
000FA:  MOVLB  0
000FC:  RCALL  0058
.................... 
....................    sh1106_cmd(0xDA); sh1106_cmd(0x12);  //com config
000FE:  MOVLW  DA
00100:  MOVLB  4
00102:  MOVWF  xCC
00104:  MOVLB  0
00106:  RCALL  0058
00108:  MOVLW  12
0010A:  MOVLB  4
0010C:  MOVWF  xCC
0010E:  MOVLB  0
00110:  RCALL  0058
....................    sh1106_cmd(0x81); sh1106_cmd(0xCF);  //contrast
00112:  MOVLW  81
00114:  MOVLB  4
00116:  MOVWF  xCC
00118:  MOVLB  0
0011A:  RCALL  0058
0011C:  MOVLW  CF
0011E:  MOVLB  4
00120:  MOVWF  xCC
00122:  MOVLB  0
00124:  RCALL  0058
....................    sh1106_cmd(0xD9); sh1106_cmd(0xF1);  //precharge
00126:  MOVLW  D9
00128:  MOVLB  4
0012A:  MOVWF  xCC
0012C:  MOVLB  0
0012E:  RCALL  0058
00130:  MOVLW  F1
00132:  MOVLB  4
00134:  MOVWF  xCC
00136:  MOVLB  0
00138:  RCALL  0058
....................    sh1106_cmd(0xDB); sh1106_cmd(0x40);  //vcom level
0013A:  MOVLW  DB
0013C:  MOVLB  4
0013E:  MOVWF  xCC
00140:  MOVLB  0
00142:  RCALL  0058
00144:  MOVLW  40
00146:  MOVLB  4
00148:  MOVWF  xCC
0014A:  MOVLB  0
0014C:  RCALL  0058
.................... 
....................    sh1106_cmd(0xA4);                   //use display ram
0014E:  MOVLW  A4
00150:  MOVLB  4
00152:  MOVWF  xCC
00154:  MOVLB  0
00156:  RCALL  0058
....................    sh1106_cmd(0xA6);                   //normal display
00158:  MOVLW  A6
0015A:  MOVLB  4
0015C:  MOVWF  xCC
0015E:  MOVLB  0
00160:  RCALL  0058
....................    sh1106_cmd(0xAF);                   //display on
00162:  MOVLW  AF
00164:  MOVLB  4
00166:  MOVWF  xCC
00168:  MOVLB  0
0016A:  RCALL  0058
0016C:  GOTO   0294 (RETURN)
.................... }
.................... 
.................... void sh1106_update_screen() {
....................    //pushes buffer to the screen
....................    for (int page = 0; page < 8; page++) {
*
00212:  MOVLB  4
00214:  CLRF   xC9
00216:  MOVF   xC9,W
00218:  SUBLW  07
0021A:  BNC   0288
....................       sh1106_cmd(0xB0 + page);
0021C:  MOVLW  B0
0021E:  ADDWF  xC9,W
00220:  MOVWF  xCB
00222:  MOVWF  xCC
00224:  MOVLB  0
00226:  RCALL  0058
....................       sh1106_cmd(0x02);
00228:  MOVLW  02
0022A:  MOVLB  4
0022C:  MOVWF  xCC
0022E:  MOVLB  0
00230:  RCALL  0058
....................       sh1106_cmd(0x10);
00232:  MOVLW  10
00234:  MOVLB  4
00236:  MOVWF  xCC
00238:  MOVLB  0
0023A:  RCALL  0058
....................       for (int col = 0; col < 128; col++) {
0023C:  MOVLB  4
0023E:  CLRF   xCA
00240:  MOVF   xCA,W
00242:  SUBLW  7F
00244:  BNC   0284
....................          sh1106_data(buffer[page][col]);
00246:  MOVLB  5
00248:  CLRF   x0F
0024A:  MOVFF  4C9,50E
0024E:  CLRF   x11
00250:  MOVLW  80
00252:  MOVWF  x10
00254:  MOVLB  0
00256:  RCALL  0170
00258:  MOVFF  01,4CB
0025C:  MOVLB  4
0025E:  MOVF   xCA,W
00260:  ADDWF  01,W
00262:  MOVWF  01
00264:  MOVLW  00
00266:  ADDWFC 02,W
00268:  MOVWF  03
0026A:  MOVF   01,W
0026C:  ADDLW  04
0026E:  MOVWF  FE9
00270:  MOVLW  00
00272:  ADDWFC 03,W
00274:  MOVWF  FEA
00276:  MOVFF  FEF,4CC
0027A:  MOVLB  0
0027C:  BRA    01E8
0027E:  MOVLB  4
00280:  INCF   xCA,F
00282:  BRA    0240
....................       }
00284:  INCF   xC9,F
00286:  BRA    0216
....................    }
00288:  MOVLB  0
0028A:  GOTO   0290 (RETURN)
.................... }
.................... 
.................... void sh1106_draw_pixel(int x, int y, int color) {
....................    //draws pixel into the buffer
....................    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return;
*
00324:  MOVLB  5
00326:  MOVF   x09,W
00328:  SUBLW  7F
0032A:  BC    0332
0032C:  BRA    0338
0032E:  BTFSC  00.0
00330:  BRA    0338
00332:  MOVF   x0A,W
00334:  SUBLW  3F
00336:  BTFSS  FD8.0
00338:  BRA    03D0
.................... 
....................    int page = y / 8;
....................    BYTE mask = 1 << (y % 8);
0033A:  RRCF   x0A,W
0033C:  MOVWF  x0C
0033E:  RRCF   x0C,F
00340:  RRCF   x0C,F
00342:  MOVLW  1F
00344:  ANDWF  x0C,F
00346:  MOVF   x0A,W
00348:  ANDLW  07
0034A:  MOVWF  01
0034C:  MOVLW  01
0034E:  MOVWF  x0D
00350:  MOVF   01,F
00352:  BZ    035C
00354:  BCF    FD8.0
00356:  RLCF   x0D,F
00358:  DECFSZ 01,F
0035A:  BRA    0354
.................... 
....................    if (color)
0035C:  MOVF   x0B,F
0035E:  BZ    039A
....................       buffer[page][x] |= mask;
00360:  CLRF   x0F
00362:  MOVFF  50C,50E
00366:  CLRF   x11
00368:  MOVLW  80
0036A:  MOVWF  x10
0036C:  MOVLB  0
0036E:  RCALL  0170
00370:  MOVFF  02,50F
00374:  MOVFF  01,50E
00378:  MOVLB  5
0037A:  MOVF   x09,W
0037C:  ADDWF  01,W
0037E:  MOVWF  01
00380:  MOVLW  00
00382:  ADDWFC 02,W
00384:  MOVWF  03
00386:  MOVF   01,W
00388:  ADDLW  04
0038A:  MOVWF  FE9
0038C:  MOVLW  00
0038E:  ADDWFC 03,W
00390:  MOVWF  FEA
00392:  MOVF   FEF,W
00394:  IORWF  x0D,W
00396:  MOVWF  FEF
00398:  BRA    03D0
....................    else
....................       buffer[page][x] &= ~mask;
0039A:  CLRF   x0F
0039C:  MOVFF  50C,50E
003A0:  CLRF   x11
003A2:  MOVLW  80
003A4:  MOVWF  x10
003A6:  MOVLB  0
003A8:  RCALL  0170
003AA:  MOVFF  01,50E
003AE:  MOVLB  5
003B0:  MOVF   x09,W
003B2:  ADDWF  01,W
003B4:  MOVWF  01
003B6:  MOVLW  00
003B8:  ADDWFC 02,W
003BA:  MOVWF  03
003BC:  MOVF   01,W
003BE:  ADDLW  04
003C0:  MOVWF  FE9
003C2:  MOVLW  00
003C4:  ADDWFC 03,W
003C6:  MOVWF  FEA
003C8:  MOVF   x0D,W
003CA:  XORLW  FF
003CC:  ANDWF  FEF,W
003CE:  MOVWF  FEF
003D0:  MOVLB  0
003D2:  RETURN 0
.................... }
.................... 
.................... void sh1106_clear_buffer() {
....................    //clears the buffer
....................    for (int page = 0; page < 8; page++) {
*
00192:  MOVLB  4
00194:  CLRF   xC5
00196:  MOVF   xC5,W
00198:  SUBLW  07
0019A:  BNC   01DE
....................       for (int col = 0; col < 128; col++) {
0019C:  CLRF   xC6
0019E:  MOVF   xC6,W
001A0:  SUBLW  7F
001A2:  BNC   01DA
....................          buffer[page][col] = 0x00;
001A4:  MOVLB  5
001A6:  CLRF   x0F
001A8:  MOVFF  4C5,50E
001AC:  CLRF   x11
001AE:  MOVLW  80
001B0:  MOVWF  x10
001B2:  MOVLB  0
001B4:  RCALL  0170
001B6:  MOVFF  01,4C7
001BA:  MOVLB  4
001BC:  MOVF   xC6,W
001BE:  ADDWF  01,W
001C0:  MOVWF  01
001C2:  MOVLW  00
001C4:  ADDWFC 02,W
001C6:  MOVWF  03
001C8:  MOVF   01,W
001CA:  ADDLW  04
001CC:  MOVWF  FE9
001CE:  MOVLW  00
001D0:  ADDWFC 03,W
001D2:  MOVWF  FEA
001D4:  CLRF   FEF
001D6:  INCF   xC6,F
001D8:  BRA    019E
....................       }
001DA:  INCF   xC5,F
001DC:  BRA    0196
....................    }
001DE:  MOVLB  0
001E0:  GOTO   01E6 (RETURN)
.................... }
.................... 
.................... /*
.................... /*
....................     controller.c - API for generic joystick controller
....................     Implements player movement with deadzones (preventing random movement) and button state
....................     Provides functions to update player position and shooting action
....................     Needs joystick driver, entity definitions and vec2 struct
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "controller.h"
.................... //controller.h
.................... 
.................... #ifndef CONTROLLER_H
.................... #define CONTROLLER_H
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... //entities.h
.................... 
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int vdir;               //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void controller_init();
.................... void controller_update(Vec2 *pos);
.................... void controller_update_button_only();
.................... 
.................... int1 is_button_pressed();
.................... int1 is_button_just_pressed();
.................... int1 is_button_just_released();
.................... 
.................... void controller_shoot(Player p, Bullet *b);
.................... 
.................... #endif
.................... 
.................... #include "../Drivers/joystick.h"
.................... //joystick.h
.................... 
.................... #ifndef JOYSTICK_H
.................... #define JOYSTICK_H
.................... 
.................... void joystick_init();
.................... 
.................... int get_Joystick_X();
.................... int get_Joystick_Y();
.................... int1 get_Joystick_SW();
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... //entities.h
.................... 
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int vdir;               //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #define MOVE_SPEED      5
.................... 
.................... #define X_DEADZONE_MIN 120
.................... #define X_DEADZONE_MAX 135
.................... #define Y_DEADZONE_MIN 120
.................... #define Y_DEADZONE_MAX 135
.................... 
.................... static int1 button_pressed = 0;
.................... static int1 last_button_state = 0;
.................... static int1 just_pressed = 0;
.................... static int1 just_released = 0;
.................... 
.................... void controller_init(){
....................     //wrapper function to initialize the driver
....................     joystick_init();
*
002CC:  BRA    029C
002CE:  GOTO   16E6 (RETURN)
.................... }
.................... 
.................... void controller_update(Vec2 *player_pos){
*
00B16:  BRA    0AD2
00B18:  MOVFF  01,4CB
00B1C:  BRA    0AF4
00B1E:  MOVFF  01,4CC
....................     //updates player position and button state
....................     int x = get_Joystick_X();  // 0–255
....................     int y = get_Joystick_Y();  // 0–255
.................... 
....................     // LEFT
....................     if (x < X_DEADZONE_MIN && player_pos->x > PLAYER_MIN_X)
00B22:  MOVLB  4
00B24:  MOVF   xCB,W
00B26:  SUBLW  77
00B28:  BNC   0B48
00B2A:  MOVFF  4C9,FE9
00B2E:  MOVFF  4CA,FEA
00B32:  MOVF   FEF,W
00B34:  SUBLW  50
00B36:  BC    0B48
....................         player_pos->x -= MOVE_SPEED;
00B38:  MOVFF  4C9,FE9
00B3C:  MOVFF  4CA,FEA
00B40:  MOVLW  05
00B42:  SUBWF  FEF,W
00B44:  MOVWF  FEF
00B46:  BRA    0B6A
....................     // RIGHT
....................     else if (x > X_DEADZONE_MAX && player_pos->x < PLAYER_MAX_X)
00B48:  MOVF   xCB,W
00B4A:  SUBLW  87
00B4C:  BC    0B6A
00B4E:  MOVFF  4C9,FE9
00B52:  MOVFF  4CA,FEA
00B56:  MOVF   FEF,W
00B58:  SUBLW  63
00B5A:  BNC   0B6A
....................         player_pos->x += MOVE_SPEED;
00B5C:  MOVFF  4C9,FE9
00B60:  MOVFF  4CA,FEA
00B64:  MOVLW  05
00B66:  ADDWF  FEF,W
00B68:  MOVWF  FEF
.................... 
....................     // DOWN
....................     if (y < Y_DEADZONE_MIN && player_pos->y < PLAYER_BOT_Y)
00B6A:  MOVF   xCC,W
00B6C:  SUBLW  77
00B6E:  BNC   0B96
00B70:  MOVLW  01
00B72:  ADDWF  xC9,W
00B74:  MOVWF  FE9
00B76:  MOVLW  00
00B78:  ADDWFC xCA,W
00B7A:  MOVWF  FEA
00B7C:  MOVF   FEF,W
00B7E:  SUBLW  31
00B80:  BNC   0B96
....................         player_pos->y += MOVE_SPEED;
00B82:  MOVLW  01
00B84:  ADDWF  xC9,W
00B86:  MOVWF  FE9
00B88:  MOVLW  00
00B8A:  ADDWFC xCA,W
00B8C:  MOVWF  FEA
00B8E:  MOVLW  05
00B90:  ADDWF  FEF,W
00B92:  MOVWF  FEF
00B94:  BRA    0BBE
....................     // UP
....................     else if (y > Y_DEADZONE_MAX && player_pos->y > PLAYER_TOP_Y)
00B96:  MOVF   xCC,W
00B98:  SUBLW  87
00B9A:  BC    0BBE
00B9C:  MOVLW  01
00B9E:  ADDWF  xC9,W
00BA0:  MOVWF  FE9
00BA2:  MOVLW  00
00BA4:  ADDWFC xCA,W
00BA6:  MOVWF  FEA
00BA8:  MOVF   FEF,F
00BAA:  BZ    0BBE
....................         player_pos->y -= MOVE_SPEED;
00BAC:  MOVLW  01
00BAE:  ADDWF  xC9,W
00BB0:  MOVWF  FE9
00BB2:  MOVLW  00
00BB4:  ADDWFC xCA,W
00BB6:  MOVWF  FEA
00BB8:  MOVLW  05
00BBA:  SUBWF  FEF,W
00BBC:  MOVWF  FEF
.................... 
....................     if (player_pos->x < PLAYER_MIN_X)
00BBE:  MOVFF  4C9,FE9
00BC2:  MOVFF  4CA,FEA
00BC6:  MOVF   FEF,W
00BC8:  SUBLW  4F
00BCA:  BNC   0BD8
....................         player_pos->x = PLAYER_MIN_X;
00BCC:  MOVFF  4C9,FE9
00BD0:  MOVFF  4CA,FEA
00BD4:  MOVLW  50
00BD6:  MOVWF  FEF
....................     if (player_pos->x > PLAYER_MAX_X)
00BD8:  MOVFF  4C9,FE9
00BDC:  MOVFF  4CA,FEA
00BE0:  MOVF   FEF,W
00BE2:  SUBLW  64
00BE4:  BC    0BF2
....................         player_pos->x = PLAYER_MAX_X;
00BE6:  MOVFF  4C9,FE9
00BEA:  MOVFF  4CA,FEA
00BEE:  MOVLW  64
00BF0:  MOVWF  FEF
.................... 
....................     if (player_pos->y < PLAYER_TOP_Y)
00BF2:  MOVLW  01
00BF4:  ADDWF  xC9,W
00BF6:  MOVWF  FE9
00BF8:  MOVLW  00
00BFA:  ADDWFC xCA,W
00BFC:  MOVWF  FEA
....................         player_pos->y = PLAYER_TOP_Y;
....................     if (player_pos->y > PLAYER_BOT_Y)
00BFE:  MOVLW  01
00C00:  ADDWF  xC9,W
00C02:  MOVWF  FE9
00C04:  MOVLW  00
00C06:  ADDWFC xCA,W
00C08:  MOVWF  FEA
00C0A:  MOVF   FEF,W
00C0C:  SUBLW  32
00C0E:  BC    0C20
....................         player_pos->y = PLAYER_BOT_Y;
00C10:  MOVLW  01
00C12:  ADDWF  xC9,W
00C14:  MOVWF  FE9
00C16:  MOVLW  00
00C18:  ADDWFC xCA,W
00C1A:  MOVWF  FEA
00C1C:  MOVLW  32
00C1E:  MOVWF  FEF
.................... 
....................     
....................     //button handling section
....................     int1 sw = get_Joystick_SW();
00C20:  MOVLB  0
00C22:  RCALL  0692
00C24:  MOVLB  4
00C26:  BCF    xCD.0
00C28:  BTFSC  01.0
00C2A:  BSF    xCD.0
....................     button_pressed = !sw;               // active-low
00C2C:  BCF    x04.0
00C2E:  BTFSS  xCD.0
00C30:  BSF    x04.0
....................     just_pressed = (button_pressed && !last_button_state);
00C32:  BCF    x04.2
00C34:  BTFSS  x04.0
00C36:  BRA    0C3E
00C38:  BTFSC  x04.1
00C3A:  BRA    0C3E
00C3C:  BSF    x04.2
....................     just_released = (!button_pressed && last_button_state);
00C3E:  BCF    x04.3
00C40:  BTFSC  x04.0
00C42:  BRA    0C4A
00C44:  BTFSS  x04.1
00C46:  BRA    0C4A
00C48:  BSF    x04.3
....................     last_button_state = button_pressed;
00C4A:  BCF    x04.1
00C4C:  BTFSC  x04.0
00C4E:  BSF    x04.1
00C50:  MOVLB  0
00C52:  GOTO   0D32 (RETURN)
.................... }
.................... 
.................... void controller_update_button_only(){
*
0069E:  RCALL  0692
006A0:  MOVLB  4
006A2:  BCF    xC5.0
006A4:  BTFSC  01.0
006A6:  BSF    xC5.0
....................     //updates only the button - used for menu screens
....................     int1 sw = get_Joystick_SW();
....................     button_pressed = !sw;               // active-low
006A8:  BCF    x04.0
006AA:  BTFSS  xC5.0
006AC:  BSF    x04.0
....................     just_pressed = (button_pressed && !last_button_state);
006AE:  BCF    x04.2
006B0:  BTFSS  x04.0
006B2:  BRA    06BA
006B4:  BTFSC  x04.1
006B6:  BRA    06BA
006B8:  BSF    x04.2
....................     just_released = (!button_pressed && last_button_state);
006BA:  BCF    x04.3
006BC:  BTFSC  x04.0
006BE:  BRA    06C6
006C0:  BTFSS  x04.1
006C2:  BRA    06C6
006C4:  BSF    x04.3
....................     last_button_state = button_pressed;
006C6:  BCF    x04.1
006C8:  BTFSC  x04.0
006CA:  BSF    x04.1
006CC:  MOVLB  0
006CE:  RETURN 0
.................... }
.................... 
.................... int1 is_button_pressed(){
....................     return button_pressed;
*
00C56:  MOVLW  00
00C58:  MOVLB  4
00C5A:  BTFSC  x04.0
00C5C:  MOVLW  01
00C5E:  MOVWF  01
00C60:  MOVLB  0
00C62:  GOTO   0C68 (RETURN)
.................... }
.................... 
.................... int1 is_button_just_pressed(){
....................     return just_pressed;
*
006D0:  MOVLW  00
006D2:  MOVLB  4
006D4:  BTFSC  x04.2
006D6:  MOVLW  01
006D8:  MOVWF  01
006DA:  MOVLB  0
006DC:  RETURN 0
.................... }
.................... 
.................... int1 is_button_just_released(){
....................     return just_released;
.................... }
.................... 
.................... void controller_shoot(Player p, Bullet *b){
....................     //allow shooting action if bullet is not active
....................     if (is_button_pressed() && !b->is_active){
*
00C66:  BRA    0C56
00C68:  MOVF   01,F
00C6A:  BZ    0CB2
00C6C:  MOVLW  02
00C6E:  MOVLB  4
00C70:  ADDWF  xCB,W
00C72:  MOVWF  FE9
00C74:  MOVLW  00
00C76:  ADDWFC xCC,W
00C78:  MOVWF  FEA
00C7A:  MOVF   FEF,F
00C7C:  BTFSC  FD8.2
00C7E:  BRA    0C84
00C80:  MOVLB  0
00C82:  BRA    0CB2
....................             b->is_active = 1;
00C84:  MOVLW  02
00C86:  ADDWF  xCB,W
00C88:  MOVWF  FE9
00C8A:  MOVLW  00
00C8C:  ADDWFC xCC,W
00C8E:  MOVWF  FEA
00C90:  MOVLW  01
00C92:  MOVWF  FEF
....................             b->pos.x = p.pos.x - 6;
00C94:  MOVFF  4CB,FE9
00C98:  MOVFF  4CC,FEA
00C9C:  MOVLW  06
00C9E:  SUBWF  xC9,W
00CA0:  MOVWF  FEF
....................             b->pos.y = p.pos.y;
00CA2:  MOVLW  01
00CA4:  ADDWF  xCB,W
00CA6:  MOVWF  FE9
00CA8:  MOVLW  00
00CAA:  ADDWFC xCC,W
00CAC:  MOVWF  FEA
00CAE:  MOVFF  4CA,FEF
00CB2:  MOVLB  0
....................         }
00CB4:  GOTO   0D48 (RETURN)
.................... }
.................... 
.................... /*
.................... /*
....................     display.c - Handles rendering and screen updates for the SH1106 OLED display
....................     Uses a framebuffer to draw pixels, digits, letters, words, and game entities (player, enemy, bullet)
....................     Provides functions to clear, update, and draw on the screen efficiently
....................     Implements movement logic for player, enemies, and bullets
....................     Includes game start and game over screen rendering
....................     Depends on sh1106 driver and utility modules for fonts, sprites, vectors, and entities
....................     Coordinate system: (0,0) top-left; (128,64) bottom-right
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
*
00886:  MOVLB  4
00888:  MOVF   xFE,W
0088A:  CLRF   01
0088C:  SUBWF  xFD,W
0088E:  BC    0896
00890:  MOVFF  4FD,00
00894:  BRA    08AE
00896:  CLRF   00
00898:  MOVLW  08
0089A:  MOVWF  xFF
0089C:  RLCF   xFD,F
0089E:  RLCF   00,F
008A0:  MOVF   xFE,W
008A2:  SUBWF  00,W
008A4:  BTFSC  FD8.0
008A6:  MOVWF  00
008A8:  RLCF   01,F
008AA:  DECFSZ xFF,F
008AC:  BRA    089C
008AE:  MOVLB  0
008B0:  RETURN 0
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "display.h"
.................... //display.h
.................... 
.................... #ifndef DISPLAY_H
.................... #define DISPLAY_H
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... //entities.h
.................... 
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int vdir;               //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void display_init();
.................... void display_clear();
.................... void display_update();
.................... 
.................... void display_gameover_screen(int score, int high_score);
.................... void display_start_screen();
.................... 
.................... void display_draw_digit(Vec2 pos, int digit);
.................... void display_draw_number(Vec2 pos, int number);
.................... 
.................... void display_draw_letter(Vec2 pos, char c);
.................... void display_draw_word(Vec2 pos, int8 word[], int length);
.................... 
.................... void display_draw_player(Vec2 pos);
.................... void display_draw_enemy(Vec2 pos);
.................... void display_draw_bullet(Vec2 pos);
.................... void display_draw_score(int score);
.................... 
.................... void display_clear_score();
.................... 
.................... void display_clear_entity(Vec2 pos, int h, int w);
.................... void display_draw_entity(Vec2 pos, int8 sprite[], int h, int w);
.................... 
.................... Vec2 display_move_player(Vec2 pos);
.................... Enemy display_move_enemy(Enemy enemy);
.................... Bullet display_move_bullet(Bullet bullet);
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/font.h"
.................... //font.h
.................... 
.................... #ifndef FONT_H
.................... #define FONT_H
.................... 
.................... #define LETTER_ARR_SIZE     17
.................... 
.................... int8 digit_font_3x5[10][3] = {
....................     {0x1F, 0x11, 0x1F}, // 0
....................     {0x00, 0x1F, 0x00}, // 1
....................     {0x1D, 0x15, 0x17}, // 2
....................     {0x15, 0x15, 0x1F}, // 3
....................     {0x07, 0x04, 0x1F}, // 4
....................     {0x17, 0x15, 0x1D}, // 5
....................     {0x1F, 0x15, 0x1D}, // 6
....................     {0x01, 0x01, 0x1F}, // 7
....................     {0x1F, 0x15, 0x1F}, // 8
....................     {0x17, 0x15, 0x1F}  // 9
.................... };
.................... 
.................... char letter_index_3x5[] = {
....................     'a', 'e', 'g', 'h', 'm', 'o', 'r', 's', 't', 'v', 'p', 'c', 'l', 'i', 'k', 'n', 'd'
.................... };
.................... 
.................... int8 letter_font_3x5[17][3] = {
....................     {0x1E, 0x05, 0x1F}, // a
....................     {0x1F, 0x15, 0x15}, // e
....................     {0x0E, 0x11, 0x1D}, // g
....................     {0x1F, 0x04, 0x1F}, // h
....................     {0x1F, 0x06, 0x1F}, // m
....................     {0x0E, 0x11, 0x0E}, // o
....................     {0x1F, 0x05, 0x1A}, // r
....................     {0x12, 0x15, 0x09}, // s
....................     {0x01, 0x1F, 0x01}, // t
....................     {0x07, 0x18, 0x07}, // v
....................     {0x1F, 0x05, 0x02}, // p
....................     {0x0E, 0x11, 0x11}, // c
....................     {0x1F, 0x10, 0x10}, // l
....................     {0x00, 0x1D, 0x00}, // i
....................     {0x1F, 0x04, 0x1B}, // k
....................     {0x1F, 0x01, 0x1E}, // n
....................     {0x1F, 0x11, 0x0E}  // d
.................... };
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/sprites.h"
.................... #ifndef SPRITES_H
.................... #define SPRITES_H
.................... 
.................... #define SPRITE_SIZE 8 
.................... 
.................... extern  int8 PLAYER_SPRITE[SPRITE_SIZE];
.................... extern  int8 ENEMY_SPRITE[SPRITE_SIZE];
.................... extern  int8 BULLET_SPRITE[SPRITE_SIZE];
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Drivers/sh1106.h"
.................... //sh1106.h
.................... #ifndef SH1106_H
.................... #define SH1106_H
.................... 
.................... #define SH1106_ADDR 0x78
.................... #define WIDTH 128
.................... #define HEIGHT 64
.................... 
.................... extern BYTE buffer[8][128];
.................... 
.................... void sh1106_cmd(unsigned char cmd);
.................... void sh1106_data(unsigned char data);
.................... void sh1106_init();
.................... void sh1106_update_screen();
.................... void sh1106_draw_pixel(int x, int y, int color);
.................... void sh1106_clear_buffer();
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... //entities.h
.................... 
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int vdir;               //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void display_init(){
....................     //wrapper for oled driver to initialize
....................     sh1106_init();
*
00292:  BRA    007E
....................     display_clear();
00294:  RCALL  01E4
....................     display_update();
00296:  RCALL  028E
00298:  GOTO   16E2 (RETURN)
.................... }
.................... 
.................... void display_clear(){
....................     //wrapper for oled driver clear
....................     sh1106_clear_buffer();
*
001E4:  BRA    0192
001E6:  RETURN 0
.................... }
.................... 
.................... void display_update(){
....................     //wrapper for oled driver update
....................     sh1106_update_screen();
*
0028E:  BRA    0212
00290:  RETURN 0
.................... }
.................... 
.................... void display_draw_digit(Vec2 pos, int digit){
....................     //draws digit to the display
....................     if (digit < 0 || digit > 9) return;
*
007FA:  MOVLB  4
007FC:  MOVF   xFF,W
007FE:  SUBLW  09
00800:  BTFSS  FD8.0
00802:  BRA    0882
.................... 
....................     for (int col = 0; col < 3; col++){
00804:  MOVLB  5
00806:  CLRF   x00
00808:  MOVF   x00,W
0080A:  SUBLW  02
0080C:  BNC   0880
....................         for (int row = 0; row < 5; row++){
0080E:  CLRF   x01
00810:  MOVF   x01,W
00812:  SUBLW  04
00814:  BNC   087C
....................             int pixel = (digit_font_3x5[digit][col] >> row) & 1;
00816:  MOVLB  4
00818:  MOVF   xFF,W
0081A:  MULLW  03
0081C:  MOVF   FF3,W
0081E:  MOVLB  5
00820:  CLRF   x04
00822:  MOVWF  x03
00824:  CLRF   03
00826:  MOVF   x00,W
00828:  ADDWF  x03,W
0082A:  MOVWF  01
0082C:  MOVF   x04,W
0082E:  ADDWFC 03,F
00830:  MOVF   01,W
00832:  ADDLW  05
00834:  MOVWF  FE9
00836:  MOVLW  04
00838:  ADDWFC 03,W
0083A:  MOVWF  FEA
0083C:  MOVFF  FEF,00
00840:  MOVF   x01,W
00842:  MOVWF  01
00844:  BZ    084E
00846:  BCF    FD8.0
00848:  RRCF   00,F
0084A:  DECFSZ 01,F
0084C:  BRA    0846
0084E:  MOVF   00,W
00850:  ANDLW  01
00852:  MOVWF  x02
....................             sh1106_draw_pixel(pos.x + col, pos.y + row, pixel);
00854:  MOVF   x00,W
00856:  MOVLB  4
00858:  ADDWF  xFD,W
0085A:  MOVLB  5
0085C:  MOVWF  x03
0085E:  MOVF   x01,W
00860:  MOVLB  4
00862:  ADDWF  xFE,W
00864:  MOVLB  5
00866:  MOVWF  x04
00868:  MOVFF  503,509
0086C:  MOVWF  x0A
0086E:  MOVFF  502,50B
00872:  MOVLB  0
00874:  RCALL  0324
00876:  MOVLB  5
00878:  INCF   x01,F
0087A:  BRA    0810
....................         }
0087C:  INCF   x00,F
0087E:  BRA    0808
00880:  MOVLB  4
....................     }
00882:  MOVLB  0
00884:  RETURN 0
.................... }
.................... 
.................... void display_draw_number(Vec2 pos, int number) {
....................     //draws complete number with positioning for each digit
....................     if (number < 0 || number > 100) return;
*
008B2:  MOVLB  4
008B4:  MOVF   xF2,W
008B6:  SUBLW  64
008B8:  BTFSS  FD8.0
008BA:  BRA    099C
.................... 
....................     if (number == 100) {
008BC:  MOVF   xF2,W
008BE:  SUBLW  64
008C0:  BNZ   090A
....................         Vec2 pos1, pos2;
.................... 
....................         display_draw_digit(pos, 1);
008C2:  MOVFF  4F1,4FE
008C6:  MOVFF  4F0,4FD
008CA:  MOVLW  01
008CC:  MOVWF  xFF
008CE:  MOVLB  0
008D0:  RCALL  07FA
.................... 
....................         pos1.x = pos.x + 4;
008D2:  MOVLW  04
008D4:  MOVLB  4
008D6:  ADDWF  xF0,W
008D8:  MOVWF  xF3
....................         pos1.y = pos.y;
008DA:  MOVFF  4F1,4F4
....................         display_draw_digit(pos1, 0);
008DE:  MOVFF  4F4,4FE
008E2:  MOVFF  4F3,4FD
008E6:  CLRF   xFF
008E8:  MOVLB  0
008EA:  RCALL  07FA
.................... 
....................         pos2.x = pos.x + 8;
008EC:  MOVLW  08
008EE:  MOVLB  4
008F0:  ADDWF  xF0,W
008F2:  MOVWF  xF5
....................         pos2.y = pos.y;
008F4:  MOVFF  4F1,4F6
....................         display_draw_digit(pos2, 0);
008F8:  MOVFF  4F6,4FE
008FC:  MOVFF  4F5,4FD
00900:  CLRF   xFF
00902:  MOVLB  0
00904:  RCALL  07FA
.................... 
....................         return;
00906:  MOVLB  4
00908:  BRA    099C
....................     }
.................... 
....................     int tens = number / 10;
....................     int ones = number % 10;
0090A:  MOVFF  4F2,4FD
0090E:  MOVLW  0A
00910:  MOVWF  xFE
00912:  MOVLB  0
00914:  RCALL  0886
00916:  MOVFF  01,4F7
0091A:  MOVFF  4F2,4FD
0091E:  MOVLW  0A
00920:  MOVLB  4
00922:  MOVWF  xFE
00924:  MOVLB  0
00926:  RCALL  0886
00928:  MOVFF  00,4F8
.................... 
....................     if (tens > 0) {
0092C:  MOVLB  4
0092E:  MOVF   xF7,F
00930:  BZ    0946
....................         display_draw_digit(pos, tens);
00932:  MOVFF  4F1,4FE
00936:  MOVFF  4F0,4FD
0093A:  MOVFF  4F7,4FF
0093E:  MOVLB  0
00940:  RCALL  07FA
....................     } else {
00942:  BRA    097E
00944:  MOVLB  4
....................         //clear tens digit area if number < 10
....................         for (int col = 0; col < 3; col++) {
00946:  CLRF   xF9
00948:  MOVF   xF9,W
0094A:  SUBLW  02
0094C:  BNC   097C
....................             for (int row = 0; row < 5; row++) {
0094E:  CLRF   xFA
00950:  MOVF   xFA,W
00952:  SUBLW  04
00954:  BNC   0978
....................                 sh1106_draw_pixel(pos.x + col, pos.y + row, 0);
00956:  MOVF   xF9,W
00958:  ADDWF  xF0,W
0095A:  MOVWF  xFD
0095C:  MOVF   xFA,W
0095E:  ADDWF  xF1,W
00960:  MOVWF  xFE
00962:  MOVFF  4FD,509
00966:  MOVFF  FE8,50A
0096A:  MOVLB  5
0096C:  CLRF   x0B
0096E:  MOVLB  0
00970:  RCALL  0324
00972:  MOVLB  4
00974:  INCF   xFA,F
00976:  BRA    0950
....................             }
00978:  INCF   xF9,F
0097A:  BRA    0948
0097C:  MOVLB  0
....................         }
....................     }
.................... 
....................     Vec2 ones_pos;
....................     ones_pos.x = pos.x + 4;
0097E:  MOVLW  04
00980:  MOVLB  4
00982:  ADDWF  xF0,W
00984:  MOVWF  xFB
....................     ones_pos.y = pos.y;
00986:  MOVFF  4F1,4FC
....................     display_draw_digit(ones_pos, ones);
0098A:  MOVFF  4FC,4FE
0098E:  MOVFF  4FB,4FD
00992:  MOVFF  4F8,4FF
00996:  MOVLB  0
00998:  RCALL  07FA
0099A:  MOVLB  4
0099C:  MOVLB  0
0099E:  RETURN 0
.................... }
.................... 
.................... void display_draw_letter(Vec2 pos, char c){
....................     //displays letter at pos.x, pos.y
....................     for (int i = 0; i < LETTER_ARR_SIZE; i++){
*
003D4:  MOVLB  5
003D6:  CLRF   x02
003D8:  MOVF   x02,W
003DA:  SUBLW  10
003DC:  BNC   046A
....................         if (letter_index_3x5[i] == c){
003DE:  CLRF   03
003E0:  MOVF   x02,W
003E2:  ADDLW  23
003E4:  MOVWF  FE9
003E6:  MOVLW  04
003E8:  ADDWFC 03,W
003EA:  MOVWF  FEA
003EC:  MOVF   x01,W
003EE:  SUBWF  FEF,W
003F0:  BNZ   0466
....................             for (int col = 0; col < 3; col++){
003F2:  CLRF   x03
003F4:  MOVF   x03,W
003F6:  SUBLW  02
003F8:  BNC   0464
....................                 for (int row = 0; row < 5; row++){
003FA:  CLRF   x04
003FC:  MOVF   x04,W
003FE:  SUBLW  04
00400:  BNC   0460
....................                     int pixel = (letter_font_3x5[i][col] >> row) & 1;
00402:  MOVF   x02,W
00404:  MULLW  03
00406:  MOVF   FF3,W
00408:  CLRF   x07
0040A:  MOVWF  x06
0040C:  CLRF   03
0040E:  MOVF   x03,W
00410:  ADDWF  x06,W
00412:  MOVWF  01
00414:  MOVF   x07,W
00416:  ADDWFC 03,F
00418:  MOVF   01,W
0041A:  ADDLW  34
0041C:  MOVWF  FE9
0041E:  MOVLW  04
00420:  ADDWFC 03,W
00422:  MOVWF  FEA
00424:  MOVFF  FEF,00
00428:  MOVF   x04,W
0042A:  MOVWF  01
0042C:  BZ    0436
0042E:  BCF    FD8.0
00430:  RRCF   00,F
00432:  DECFSZ 01,F
00434:  BRA    042E
00436:  MOVF   00,W
00438:  ANDLW  01
0043A:  MOVWF  x05
....................                     sh1106_draw_pixel(pos.x + col, pos.y + row, pixel);
0043C:  MOVF   x03,W
0043E:  MOVLB  4
00440:  ADDWF  xFF,W
00442:  MOVLB  5
00444:  MOVWF  x06
00446:  MOVF   x04,W
00448:  ADDWF  x00,W
0044A:  MOVWF  x07
0044C:  MOVFF  506,509
00450:  MOVWF  x0A
00452:  MOVFF  505,50B
00456:  MOVLB  0
00458:  RCALL  0324
0045A:  MOVLB  5
0045C:  INCF   x04,F
0045E:  BRA    03FC
....................                 }
00460:  INCF   x03,F
00462:  BRA    03F4
....................             }
....................             return;
00464:  BRA    046A
....................         }
00466:  INCF   x02,F
00468:  BRA    03D8
....................     }
0046A:  MOVLB  0
0046C:  GOTO   0496 (RETURN)
.................... }
.................... 
.................... void display_draw_word(Vec2 pos, int8 word[], int length){
....................     //draws word at (pos.x, pos.y)
....................     for (int i = 0; i < length; i++){
00470:  MOVLB  4
00472:  CLRF   xFD
00474:  MOVF   xFC,W
00476:  SUBWF  xFD,W
00478:  BC    04A0
....................         display_draw_letter(pos, word[i]);
0047A:  MOVF   xFD,W
0047C:  ADDWF  xFA,W
0047E:  MOVWF  FE9
00480:  MOVLW  00
00482:  ADDWFC xFB,W
00484:  MOVWF  FEA
00486:  MOVFF  FEF,501
0048A:  MOVFF  4F9,500
0048E:  MOVFF  4F8,4FF
00492:  MOVLB  0
00494:  BRA    03D4
....................         pos.x += 4; // move right to draw next letter
00496:  MOVLW  04
00498:  MOVLB  4
0049A:  ADDWF  xF8,F
0049C:  INCF   xFD,F
0049E:  BRA    0474
....................     }
004A0:  MOVLB  0
004A2:  RETURN 0
.................... }
.................... 
.................... void display_draw_entity(Vec2 pos, int8 *sprite_data, int h, int w){
....................     //draws entity
....................     int i, j;
....................     for (i = 0; i < h; i++){
004A4:  MOVLB  5
004A6:  CLRF   x00
004A8:  MOVLB  4
004AA:  MOVF   xFE,W
004AC:  MOVLB  5
004AE:  SUBWF  x00,W
004B0:  BC    0512
....................         for (j = 0; j < w; j++){
004B2:  CLRF   x01
004B4:  MOVLB  4
004B6:  MOVF   xFF,W
004B8:  MOVLB  5
004BA:  SUBWF  x01,W
004BC:  BC    050E
....................             int pixel = (sprite_data[i] >> j) & 1;
004BE:  MOVF   x00,W
004C0:  MOVLB  4
004C2:  ADDWF  xFC,W
004C4:  MOVWF  FE9
004C6:  MOVLW  00
004C8:  ADDWFC xFD,W
004CA:  MOVWF  FEA
004CC:  MOVFF  FEF,00
004D0:  MOVLB  5
004D2:  MOVF   x01,W
004D4:  MOVWF  01
004D6:  BZ    04E0
004D8:  BCF    FD8.0
004DA:  RRCF   00,F
004DC:  DECFSZ 01,F
004DE:  BRA    04D8
004E0:  MOVF   00,W
004E2:  ANDLW  01
004E4:  MOVWF  x02
....................             sh1106_draw_pixel(pos.x + j, pos.y + i, pixel);
004E6:  MOVF   x01,W
004E8:  MOVLB  4
004EA:  ADDWF  xFA,W
004EC:  MOVLB  5
004EE:  MOVWF  x03
004F0:  MOVF   x00,W
004F2:  MOVLB  4
004F4:  ADDWF  xFB,W
004F6:  MOVLB  5
004F8:  MOVWF  x04
004FA:  MOVFF  503,509
004FE:  MOVWF  x0A
00500:  MOVFF  502,50B
00504:  MOVLB  0
00506:  RCALL  0324
00508:  MOVLB  5
0050A:  INCF   x01,F
0050C:  BRA    04B4
....................         }
0050E:  INCF   x00,F
00510:  BRA    04A8
....................     }
00512:  MOVLB  0
00514:  RETURN 0
.................... }
.................... 
.................... void display_clear_entity(Vec2 pos, int h, int w){
....................     //clears an entity
....................     int i, j;
....................     for (i = 0; i < h; i++){
*
00A96:  MOVLB  4
00A98:  CLRF   xE0
00A9A:  MOVF   xDE,W
00A9C:  SUBWF  xE0,W
00A9E:  BC    0ACE
....................         for (j = 0; j < w; j++){
00AA0:  CLRF   xE1
00AA2:  MOVF   xDF,W
00AA4:  SUBWF  xE1,W
00AA6:  BC    0ACA
....................             sh1106_draw_pixel(pos.x + j, pos.y + i, 0);
00AA8:  MOVF   xE1,W
00AAA:  ADDWF  xDC,W
00AAC:  MOVWF  xE2
00AAE:  MOVF   xE0,W
00AB0:  ADDWF  xDD,W
00AB2:  MOVWF  xE3
00AB4:  MOVFF  4E2,509
00AB8:  MOVFF  FE8,50A
00ABC:  MOVLB  5
00ABE:  CLRF   x0B
00AC0:  MOVLB  0
00AC2:  RCALL  0324
00AC4:  MOVLB  4
00AC6:  INCF   xE1,F
00AC8:  BRA    0AA2
....................         }
00ACA:  INCF   xE0,F
00ACC:  BRA    0A9A
....................     }
00ACE:  MOVLB  0
00AD0:  RETURN 0
.................... }
.................... 
.................... void display_draw_player(Vec2 pos){
....................     //draws player at pos.x and pos.y
....................     display_draw_entity(pos, PLAYER_SPRITE, 8, 8);
*
00516:  MOVFF  4F9,4FB
0051A:  MOVFF  4F8,4FA
0051E:  MOVLW  04
00520:  MOVLB  4
00522:  MOVWF  xFD
00524:  MOVLW  67
00526:  MOVWF  xFC
00528:  MOVLW  08
0052A:  MOVWF  xFE
0052C:  MOVWF  xFF
0052E:  MOVLB  0
00530:  RCALL  04A4
00532:  RETURN 0
.................... }
.................... 
.................... void display_draw_enemy(Vec2 pos){
....................     //draws enemy at pos.x and pos.y
....................     display_draw_entity(pos, ENEMY_SPRITE, 8, 8);
*
00552:  MOVFF  4F9,4FB
00556:  MOVFF  4F8,4FA
0055A:  MOVLW  04
0055C:  MOVLB  4
0055E:  MOVWF  xFD
00560:  MOVLW  6F
00562:  MOVWF  xFC
00564:  MOVLW  08
00566:  MOVWF  xFE
00568:  MOVWF  xFF
0056A:  MOVLB  0
0056C:  RCALL  04A4
0056E:  RETURN 0
.................... }
.................... 
.................... void display_draw_bullet(Vec2 pos){
....................     //draws bullet at pos.x and pos.y
....................     display_draw_entity(pos, BULLET_SPRITE, 8, 8);
*
00534:  MOVFF  4F9,4FB
00538:  MOVFF  4F8,4FA
0053C:  MOVLW  04
0053E:  MOVLB  4
00540:  MOVWF  xFD
00542:  MOVLW  77
00544:  MOVWF  xFC
00546:  MOVLW  08
00548:  MOVWF  xFE
0054A:  MOVWF  xFF
0054C:  MOVLB  0
0054E:  RCALL  04A4
00550:  RETURN 0
.................... }
.................... 
.................... void display_draw_score(int score){
....................     //draws score at fixed position (pos)
....................     Vec2 pos = {112, 0};
*
009A0:  MOVLW  70
009A2:  MOVLB  4
009A4:  MOVWF  xCB
009A6:  CLRF   xCC
....................     display_draw_number(pos, score);
009A8:  MOVFF  4CC,4F1
009AC:  MOVFF  4CB,4F0
009B0:  MOVFF  4CA,4F2
009B4:  MOVLB  0
009B6:  RCALL  08B2
009B8:  RETURN 0
.................... }
.................... 
.................... void display_clear_score(){
....................     //clears score from fixed position (pos)
....................     Vec2 pos = {112, 0};
*
01268:  MOVLW  70
0126A:  MOVLB  4
0126C:  MOVWF  xCA
0126E:  CLRF   xCB
....................     display_clear_entity(pos, 11, 5);
01270:  MOVFF  4CB,4DD
01274:  MOVFF  4CA,4DC
01278:  MOVLW  0B
0127A:  MOVWF  xDE
0127C:  MOVLW  05
0127E:  MOVWF  xDF
01280:  MOVLB  0
01282:  RCALL  0A96
01284:  GOTO   12BE (RETURN)
.................... }
.................... 
.................... Vec2 display_move_player(Vec2 pos){
*
00CB8:  MOVFF  4CA,4CC
00CBC:  MOVFF  4C9,4CB
....................     //handles player movement
....................     Vec2 last_pos = pos;
.................... 
....................     display_clear_entity(last_pos, 8, 8);
00CC0:  MOVFF  4CC,4DD
00CC4:  MOVFF  4CB,4DC
00CC8:  MOVLW  08
00CCA:  MOVLB  4
00CCC:  MOVWF  xDE
00CCE:  MOVWF  xDF
00CD0:  MOVLB  0
00CD2:  RCALL  0A96
.................... 
....................     if (pos.x < PLAYER_MIN_X) pos.x = PLAYER_MIN_X;
00CD4:  MOVLB  4
00CD6:  MOVF   xC9,W
00CD8:  SUBLW  4F
00CDA:  BNC   0CE0
00CDC:  MOVLW  50
00CDE:  MOVWF  xC9
....................     if (pos.x > PLAYER_MAX_X) pos.x = PLAYER_MAX_X;
00CE0:  MOVF   xC9,W
00CE2:  SUBLW  64
00CE4:  BC    0CEA
00CE6:  MOVLW  64
00CE8:  MOVWF  xC9
.................... 
....................     if (pos.y < PLAYER_TOP_Y) pos.y = PLAYER_TOP_Y;
....................     if (pos.y > PLAYER_BOT_Y) pos.y = PLAYER_BOT_Y;
00CEA:  MOVF   xCA,W
00CEC:  SUBLW  32
00CEE:  BC    0CF4
00CF0:  MOVLW  32
00CF2:  MOVWF  xCA
.................... 
....................     display_draw_player(pos);
00CF4:  MOVFF  4CA,4F9
00CF8:  MOVFF  4C9,4F8
00CFC:  MOVLB  0
00CFE:  RCALL  0516
....................     return pos;
00D00:  MOVLB  4
00D02:  MOVFF  4C9,01
00D06:  MOVFF  4CA,02
00D0A:  MOVLB  0
00D0C:  GOTO   0D52 (RETURN)
.................... }
.................... 
.................... Enemy display_move_enemy(Enemy enemy){
*
01034:  MOVFF  4D6,4DB
01038:  MOVFF  4D5,4DA
....................     //handles enemy movement
....................     Vec2 last_pos = enemy.pos;
.................... 
....................     if (enemy.reached_y_edge != 0){
0103C:  MOVLB  4
0103E:  MOVF   xD8,F
01040:  BZ    107E
....................         enemy.pos.x += ENEMY_STEP_X;
01042:  MOVLW  0D
01044:  ADDWF  xD5,F
....................         enemy.vdir = (enemy.reached_y_edge == 1)? 1 : -1;
01046:  DECFSZ xD8,W
01048:  BRA    104E
0104A:  MOVLW  01
0104C:  BRA    1050
0104E:  MOVLW  FF
01050:  MOVWF  xD7
....................         enemy.reached_y_edge = 0;
01052:  CLRF   xD8
.................... 
....................         display_clear_entity(last_pos, 8, 8);
01054:  MOVFF  4DB,4DD
01058:  MOVFF  4DA,4DC
0105C:  MOVLW  08
0105E:  MOVWF  xDE
01060:  MOVWF  xDF
01062:  MOVLB  0
01064:  RCALL  0A96
....................         display_draw_enemy(enemy.pos);
01066:  MOVFF  4D6,4F9
0106A:  MOVFF  4D5,4F8
0106E:  CALL   0552
....................         return enemy;
01072:  MOVLW  D5
01074:  MOVWF  01
01076:  MOVLW  04
01078:  MOVWF  02
0107A:  BRA    10C8
0107C:  MOVLB  4
....................     }
.................... 
....................     enemy.pos.y += enemy.vdir * ENEMY_STEP_Y;
0107E:  MOVF   xD7,W
01080:  MULLW  05
01082:  MOVF   FF3,W
01084:  ADDWF  xD6,F
.................... 
....................     if (enemy.pos.y <= ENEMY_TOP_Y){
01086:  MOVF   xD6,W
01088:  SUBLW  02
0108A:  BNC   1096
....................         enemy.pos.y = ENEMY_TOP_Y;
0108C:  MOVLW  02
0108E:  MOVWF  xD6
....................         enemy.reached_y_edge = 1;       //reached top
01090:  MOVLW  01
01092:  MOVWF  xD8
....................     }else if (enemy.pos.y >= ENEMY_BOT_Y){
01094:  BRA    10A2
01096:  MOVF   xD6,W
01098:  SUBLW  31
0109A:  BC    10A2
....................         enemy.pos.y = ENEMY_BOT_Y;
0109C:  MOVLW  32
0109E:  MOVWF  xD6
....................         enemy.reached_y_edge = -1;      //reached bottom
010A0:  SETF   xD8
....................     }
.................... 
....................     display_clear_entity(last_pos, 8, 8);
010A2:  MOVFF  4DB,4DD
010A6:  MOVFF  4DA,4DC
010AA:  MOVLW  08
010AC:  MOVWF  xDE
010AE:  MOVWF  xDF
010B0:  MOVLB  0
010B2:  RCALL  0A96
....................     display_draw_enemy(enemy.pos);
010B4:  MOVFF  4D6,4F9
010B8:  MOVFF  4D5,4F8
010BC:  CALL   0552
.................... 
....................     return enemy;
010C0:  MOVLW  D5
010C2:  MOVWF  01
010C4:  MOVLW  04
010C6:  MOVWF  02
010C8:  GOTO   11BA (RETURN)
.................... }
.................... 
.................... 
.................... Bullet display_move_bullet(Bullet bullet){
....................     //handles bullet movement
....................     if (!bullet.is_active) return bullet;
*
00D5C:  MOVLB  4
00D5E:  MOVF   xCB,F
00D60:  BNZ   0D70
00D62:  MOVFF  4C9,01
00D66:  MOVFF  4CA,02
00D6A:  MOVFF  4CB,03
00D6E:  BRA    0DA8
.................... 
....................     Vec2 last_pos = bullet.pos;
00D70:  MOVFF  4CA,4CD
00D74:  MOVFF  4C9,4CC
....................     bullet.pos.x -= BULLET_SPEED;
00D78:  MOVLW  0C
00D7A:  SUBWF  xC9,F
.................... 
....................     display_clear_entity(last_pos, 8, 8);
00D7C:  MOVFF  4CD,4DD
00D80:  MOVFF  4CC,4DC
00D84:  MOVLW  08
00D86:  MOVWF  xDE
00D88:  MOVWF  xDF
00D8A:  MOVLB  0
00D8C:  RCALL  0A96
....................     display_draw_bullet(bullet.pos);
00D8E:  MOVFF  4CA,4F9
00D92:  MOVFF  4C9,4F8
00D96:  CALL   0534
....................     
....................     return bullet;
00D9A:  MOVFF  4C9,01
00D9E:  MOVFF  4CA,02
00DA2:  MOVFF  4CB,03
00DA6:  MOVLB  4
00DA8:  MOVLB  0
00DAA:  GOTO   0DBC (RETURN)
.................... }
.................... 
.................... void display_gameover_screen(int score, int high_score){
....................     //draws game over screen
....................     Vec2 gameover_pos = {46, 10};
*
0143A:  MOVLW  2E
0143C:  MOVLB  4
0143E:  MOVWF  xC7
01440:  MOVLW  0A
01442:  MOVWF  xC8
.................... 
....................     Vec2 hs_label_pos = {10, 20};
01444:  MOVWF  xC9
01446:  MOVLW  14
01448:  MOVWF  xCA
....................     Vec2 hs_pos = {10, 26};
0144A:  MOVLW  0A
0144C:  MOVWF  xCB
0144E:  MOVLW  1A
01450:  MOVWF  xCC
.................... 
....................     Vec2 ss_label_pos = {110, 20};
01452:  MOVLW  6E
01454:  MOVWF  xCD
01456:  MOVLW  14
01458:  MOVWF  xCE
....................     Vec2 ss_pos = {110, 26};
0145A:  MOVLW  6E
0145C:  MOVWF  xCF
0145E:  MOVLW  1A
01460:  MOVWF  xD0
.................... 
....................     Vec2 restart_label_pos = {32, 54};
01462:  MOVLW  20
01464:  MOVWF  xD1
01466:  MOVLW  36
01468:  MOVWF  xD2
.................... 
....................     int8 gameover_text[] = {'g', 'a', 'm', 'e', ' ', 'o', 'v', 'e', 'r'};
0146A:  MOVLW  67
0146C:  MOVWF  xD3
0146E:  MOVLW  61
01470:  MOVWF  xD4
01472:  MOVLW  6D
01474:  MOVWF  xD5
01476:  MOVLW  65
01478:  MOVWF  xD6
0147A:  MOVLW  20
0147C:  MOVWF  xD7
0147E:  MOVLW  6F
01480:  MOVWF  xD8
01482:  MOVLW  76
01484:  MOVWF  xD9
01486:  MOVLW  65
01488:  MOVWF  xDA
0148A:  MOVLW  72
0148C:  MOVWF  xDB
....................     int8 hs_text[] = {'h', 's'};
0148E:  MOVLW  68
01490:  MOVWF  xDC
01492:  MOVLW  73
01494:  MOVWF  xDD
....................     int8 ss_text[] = {'s', 's'};
01496:  MOVWF  xDE
01498:  MOVWF  xDF
....................     int8 click_to_restart_text[] = {
....................         'c', 'l', 'i', 'c', 'k', ' ',
....................         't', 'o', ' ',
....................         'r', 'e', 's', 't', 'a', 'r', 't'
....................     };
0149A:  MOVLW  63
0149C:  MOVWF  xE0
0149E:  MOVLW  6C
014A0:  MOVWF  xE1
014A2:  MOVLW  69
014A4:  MOVWF  xE2
014A6:  MOVLW  63
014A8:  MOVWF  xE3
014AA:  MOVLW  6B
014AC:  MOVWF  xE4
014AE:  MOVLW  20
014B0:  MOVWF  xE5
014B2:  MOVLW  74
014B4:  MOVWF  xE6
014B6:  MOVLW  6F
014B8:  MOVWF  xE7
014BA:  MOVLW  20
014BC:  MOVWF  xE8
014BE:  MOVLW  72
014C0:  MOVWF  xE9
014C2:  MOVLW  65
014C4:  MOVWF  xEA
014C6:  MOVLW  73
014C8:  MOVWF  xEB
014CA:  MOVLW  74
014CC:  MOVWF  xEC
014CE:  MOVLW  61
014D0:  MOVWF  xED
014D2:  MOVLW  72
014D4:  MOVWF  xEE
014D6:  MOVLW  74
014D8:  MOVWF  xEF
....................     
....................     display_draw_word(gameover_pos, gameover_text, 9);
014DA:  MOVFF  4C8,4F9
014DE:  MOVFF  4C7,4F8
014E2:  MOVLW  04
014E4:  MOVWF  xFB
014E6:  MOVLW  D3
014E8:  MOVWF  xFA
014EA:  MOVLW  09
014EC:  MOVWF  xFC
014EE:  MOVLB  0
014F0:  CALL   0470
....................     display_draw_word(hs_label_pos, hs_text, 2);
014F4:  MOVFF  4CA,4F9
014F8:  MOVFF  4C9,4F8
014FC:  MOVLW  04
014FE:  MOVLB  4
01500:  MOVWF  xFB
01502:  MOVLW  DC
01504:  MOVWF  xFA
01506:  MOVLW  02
01508:  MOVWF  xFC
0150A:  MOVLB  0
0150C:  CALL   0470
....................     display_draw_word(ss_label_pos, ss_text, 2);
01510:  MOVFF  4CE,4F9
01514:  MOVFF  4CD,4F8
01518:  MOVLW  04
0151A:  MOVLB  4
0151C:  MOVWF  xFB
0151E:  MOVLW  DE
01520:  MOVWF  xFA
01522:  MOVLW  02
01524:  MOVWF  xFC
01526:  MOVLB  0
01528:  CALL   0470
....................     display_draw_word(restart_label_pos, click_to_restart_text, 16);
0152C:  MOVFF  4D2,4F9
01530:  MOVFF  4D1,4F8
01534:  MOVLW  04
01536:  MOVLB  4
01538:  MOVWF  xFB
0153A:  MOVLW  E0
0153C:  MOVWF  xFA
0153E:  MOVLW  10
01540:  MOVWF  xFC
01542:  MOVLB  0
01544:  CALL   0470
.................... 
....................     display_draw_number(hs_pos, high_score);
01548:  MOVFF  4CC,4F1
0154C:  MOVFF  4CB,4F0
01550:  MOVFF  4C6,4F2
01554:  CALL   08B2
....................     display_draw_number(ss_pos, score);
01558:  MOVFF  4D0,4F1
0155C:  MOVFF  4CF,4F0
01560:  MOVFF  4C5,4F2
01564:  CALL   08B2
01568:  GOTO   158A (RETURN)
.................... }
.................... 
.................... void display_start_screen(){
....................     //draws start screen
....................     Vec2 title_pos = {8, 5};
*
00570:  MOVLW  08
00572:  MOVLB  4
00574:  MOVWF  xC4
00576:  MOVLW  05
00578:  MOVWF  xC5
....................     Vec2 start_pos = {36, 59};
0057A:  MOVLW  24
0057C:  MOVWF  xC6
0057E:  MOVLW  3B
00580:  MOVWF  xC7
.................... 
....................     Vec2 enemy_pos  = {10, 32};
00582:  MOVLW  0A
00584:  MOVWF  xC8
00586:  MOVLW  20
00588:  MOVWF  xC9
....................     Vec2 bullet_pos = {50, 32};
0058A:  MOVLW  32
0058C:  MOVWF  xCA
0058E:  MOVLW  20
00590:  MOVWF  xCB
....................     Vec2 player_pos = {90, 32};
00592:  MOVLW  5A
00594:  MOVWF  xCC
00596:  MOVLW  20
00598:  MOVWF  xCD
.................... 
....................     int8 title_text[] = {
....................         's', 'p', 'a', 'c', 'e', ' ',
....................         'i', 'n', 'v', 'a', 'd', 'e', 'r', 's',
....................         ' ', ' ', ' ',
....................         'p', 'i', 'c', ' ',
....................         'e', 'd', 'i', 't', 'i', 'o', 'n'
....................     };
0059A:  MOVLW  73
0059C:  MOVWF  xCE
0059E:  MOVLW  70
005A0:  MOVWF  xCF
005A2:  MOVLW  61
005A4:  MOVWF  xD0
005A6:  MOVLW  63
005A8:  MOVWF  xD1
005AA:  MOVLW  65
005AC:  MOVWF  xD2
005AE:  MOVLW  20
005B0:  MOVWF  xD3
005B2:  MOVLW  69
005B4:  MOVWF  xD4
005B6:  MOVLW  6E
005B8:  MOVWF  xD5
005BA:  MOVLW  76
005BC:  MOVWF  xD6
005BE:  MOVLW  61
005C0:  MOVWF  xD7
005C2:  MOVLW  64
005C4:  MOVWF  xD8
005C6:  MOVLW  65
005C8:  MOVWF  xD9
005CA:  MOVLW  72
005CC:  MOVWF  xDA
005CE:  MOVLW  73
005D0:  MOVWF  xDB
005D2:  MOVLW  20
005D4:  MOVWF  xDC
005D6:  MOVWF  xDD
005D8:  MOVWF  xDE
005DA:  MOVLW  70
005DC:  MOVWF  xDF
005DE:  MOVLW  69
005E0:  MOVWF  xE0
005E2:  MOVLW  63
005E4:  MOVWF  xE1
005E6:  MOVLW  20
005E8:  MOVWF  xE2
005EA:  MOVLW  65
005EC:  MOVWF  xE3
005EE:  MOVLW  64
005F0:  MOVWF  xE4
005F2:  MOVLW  69
005F4:  MOVWF  xE5
005F6:  MOVLW  74
005F8:  MOVWF  xE6
005FA:  MOVLW  69
005FC:  MOVWF  xE7
005FE:  MOVLW  6F
00600:  MOVWF  xE8
00602:  MOVLW  6E
00604:  MOVWF  xE9
.................... 
....................     int8 start_text[] = {
....................         'c', 'l', 'i', 'c', 'k', ' ',
....................         't', 'o', ' ',
....................         's', 't', 'a', 'r', 't'
....................     };
00606:  MOVLW  63
00608:  MOVWF  xEA
0060A:  MOVLW  6C
0060C:  MOVWF  xEB
0060E:  MOVLW  69
00610:  MOVWF  xEC
00612:  MOVLW  63
00614:  MOVWF  xED
00616:  MOVLW  6B
00618:  MOVWF  xEE
0061A:  MOVLW  20
0061C:  MOVWF  xEF
0061E:  MOVLW  74
00620:  MOVWF  xF0
00622:  MOVLW  6F
00624:  MOVWF  xF1
00626:  MOVLW  20
00628:  MOVWF  xF2
0062A:  MOVLW  73
0062C:  MOVWF  xF3
0062E:  MOVLW  74
00630:  MOVWF  xF4
00632:  MOVLW  61
00634:  MOVWF  xF5
00636:  MOVLW  72
00638:  MOVWF  xF6
0063A:  MOVLW  74
0063C:  MOVWF  xF7
.................... 
....................     display_draw_word(title_pos, title_text, 28);
0063E:  MOVFF  4C5,4F9
00642:  MOVFF  4C4,4F8
00646:  MOVLW  04
00648:  MOVWF  xFB
0064A:  MOVLW  CE
0064C:  MOVWF  xFA
0064E:  MOVLW  1C
00650:  MOVWF  xFC
00652:  MOVLB  0
00654:  RCALL  0470
....................     display_draw_word(start_pos, start_text, 14);
00656:  MOVFF  4C7,4F9
0065A:  MOVFF  4C6,4F8
0065E:  MOVLW  04
00660:  MOVLB  4
00662:  MOVWF  xFB
00664:  MOVLW  EA
00666:  MOVWF  xFA
00668:  MOVLW  0E
0066A:  MOVWF  xFC
0066C:  MOVLB  0
0066E:  RCALL  0470
.................... 
....................     display_draw_player(player_pos);
00670:  MOVFF  4CD,4F9
00674:  MOVFF  4CC,4F8
00678:  RCALL  0516
....................     display_draw_bullet(bullet_pos);
0067A:  MOVFF  4CB,4F9
0067E:  MOVFF  4CA,4F8
00682:  RCALL  0534
....................     display_draw_enemy(enemy_pos);
00684:  MOVFF  4C9,4F9
00688:  MOVFF  4C8,4F8
0068C:  RCALL  0552
0068E:  GOTO   06E2 (RETURN)
.................... }
.................... 
.................... /*
.................... /*
....................     memory.c - Highscore saving system using 24LC512 EEPROM
....................     Provides functions to load and save the game's highscore
....................     Reads/writes single byte from/to EEPROM at predefined address
....................     Depends on eeprom_24LC512 driver for I2C communication
....................     Ensures highscore is only updated if new score is higher
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "../Drivers/eeprom_24LC512.h"
.................... //eeprom_24LC512.h
.................... 
.................... #ifndef EEPROM_24LC512
.................... #define EEPROM_24LC512
.................... 
.................... #define EEPROM_ADDR_WRITE  0xA0
.................... #define EEPROM_ADDR_READ   0xA1
.................... 
.................... #define STATE_ADDR 0x0000
.................... 
.................... void eeprom_write_byte(BYTE data);
.................... BYTE eeprom_read_byte();
.................... 
.................... #endif
.................... 
.................... 
.................... int load_highscore(){
*
013CC:  BRA    137A
013CE:  MOVFF  01,4C5
....................     int highscore = eeprom_read_byte();
....................     return highscore;
013D2:  MOVLB  4
013D4:  MOVFF  4C5,01
013D8:  MOVLB  0
013DA:  GOTO   156E (RETURN)
.................... }
.................... 
.................... void save_highscore(int score, int hs){
....................     if (score > hs){
*
01422:  MOVLB  4
01424:  MOVF   xC5,W
01426:  SUBWF  xC6,W
01428:  BC    1434
....................         eeprom_write_byte(score);
0142A:  MOVFF  4C5,4C7
0142E:  MOVLB  0
01430:  BRA    13DE
01432:  MOVLB  4
....................     }
01434:  MOVLB  0
01436:  GOTO   157C (RETURN)
.................... }
.................... 
.................... /*
.................... /*
....................     Contains collision system 
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "entities.h"
.................... //entities.h
.................... 
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int vdir;               //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "sprites.h"
.................... #ifndef SPRITES_H
.................... #define SPRITES_H
.................... 
.................... #define SPRITE_SIZE 8 
.................... 
.................... extern  int8 PLAYER_SPRITE[SPRITE_SIZE];
.................... extern  int8 ENEMY_SPRITE[SPRITE_SIZE];
.................... extern  int8 BULLET_SPRITE[SPRITE_SIZE];
.................... 
.................... #endif
.................... 
.................... 
.................... int check_collisionBE(Bullet b, Enemy e){
....................     return (b.pos.x <= e.pos.x + SPRITE_SIZE - 1) &&
....................        (b.pos.x + SPRITE_SIZE - 1 >= e.pos.x) &&
....................        (b.pos.y <= e.pos.y + SPRITE_SIZE - 1) &&
....................        (b.pos.y + SPRITE_SIZE - 1 >= e.pos.y);
*
00DCA:  MOVLW  08
00DCC:  MOVLB  4
00DCE:  ADDWF  xCF,W
00DD0:  ADDLW  FF
00DD2:  SUBWF  xCC,W
00DD4:  BZ    0DD8
00DD6:  BC    0DFC
00DD8:  MOVLW  08
00DDA:  ADDWF  xCC,W
00DDC:  ADDLW  FF
00DDE:  SUBWF  xCF,W
00DE0:  BZ    0DE4
00DE2:  BC    0DFC
00DE4:  MOVLW  08
00DE6:  ADDWF  xD0,W
00DE8:  ADDLW  FF
00DEA:  SUBWF  xCD,W
00DEC:  BZ    0DF0
00DEE:  BC    0DFC
00DF0:  MOVLW  08
00DF2:  ADDWF  xCD,W
00DF4:  ADDLW  FF
00DF6:  SUBWF  xD0,W
00DF8:  BZ    0E00
00DFA:  BNC   0E00
00DFC:  MOVLW  00
00DFE:  BRA    0E02
00E00:  MOVLW  01
00E02:  MOVWF  01
00E04:  MOVLB  0
00E06:  GOTO   0ECE (RETURN)
.................... }
.................... 
.................... /*
.................... /*
....................     sprites.c 
....................     Contains sprites for all gam entities
.................... */
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... 
.................... #include "sprites.h"
.................... #ifndef SPRITES_H
.................... #define SPRITES_H
.................... 
.................... #define SPRITE_SIZE 8 
.................... 
.................... extern  int8 PLAYER_SPRITE[SPRITE_SIZE];
.................... extern  int8 ENEMY_SPRITE[SPRITE_SIZE];
.................... extern  int8 BULLET_SPRITE[SPRITE_SIZE];
.................... 
.................... #endif
.................... 
.................... 
.................... int8 PLAYER_SPRITE[SPRITE_SIZE] = {
....................     0x70, 0x8c, 0x82, 0x81, 0x81, 0x82, 0x8c, 0x70
.................... };
.................... 
.................... int8 ENEMY_SPRITE[SPRITE_SIZE] = {
....................     0x18, 0x24, 0x42, 0x81, 0x42, 0x5a, 0x24, 0xc3
.................... };
.................... 
.................... int8 BULLET_SPRITE[SPRITE_SIZE] = {
....................     0x00, 0x00, 0x00, 0x7e, 0x7e, 0x00, 0x00, 0x00
.................... };
.................... 
.................... //main.c
.................... //main.c
.................... 
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
.................... 
.................... #list
.................... 
.................... #fuses INTRC_IO, NOWDT, NOLVP, NOPROTECT
.................... #use delay(clock=16MHz)
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)
.................... 
.................... #include "API/display.h"
.................... //display.h
.................... 
.................... #ifndef DISPLAY_H
.................... #define DISPLAY_H
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... //entities.h
.................... 
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int vdir;               //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void display_init();
.................... void display_clear();
.................... void display_update();
.................... 
.................... void display_gameover_screen(int score, int high_score);
.................... void display_start_screen();
.................... 
.................... void display_draw_digit(Vec2 pos, int digit);
.................... void display_draw_number(Vec2 pos, int number);
.................... 
.................... void display_draw_letter(Vec2 pos, char c);
.................... void display_draw_word(Vec2 pos, int8 word[], int length);
.................... 
.................... void display_draw_player(Vec2 pos);
.................... void display_draw_enemy(Vec2 pos);
.................... void display_draw_bullet(Vec2 pos);
.................... void display_draw_score(int score);
.................... 
.................... void display_clear_score();
.................... 
.................... void display_clear_entity(Vec2 pos, int h, int w);
.................... void display_draw_entity(Vec2 pos, int8 sprite[], int h, int w);
.................... 
.................... Vec2 display_move_player(Vec2 pos);
.................... Enemy display_move_enemy(Enemy enemy);
.................... Bullet display_move_bullet(Bullet bullet);
.................... 
.................... #endif
.................... 
.................... #include "API/controller.h"
.................... //controller.h
.................... 
.................... #ifndef CONTROLLER_H
.................... #define CONTROLLER_H
.................... 
.................... #include "../Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... #include "../Utilities/entities.h"
.................... //entities.h
.................... 
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int vdir;               //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... 
.................... void controller_init();
.................... void controller_update(Vec2 *pos);
.................... void controller_update_button_only();
.................... 
.................... int1 is_button_pressed();
.................... int1 is_button_just_pressed();
.................... int1 is_button_just_released();
.................... 
.................... void controller_shoot(Player p, Bullet *b);
.................... 
.................... #endif
.................... 
.................... #include "API/memory.h"
.................... //memory.h
.................... 
.................... #ifndef MEMORY_H
.................... #define MEMORY_H
.................... 
.................... int load_highscore();
.................... void save_highscore(int score, int hs); //score needs to be 8 bit max
.................... 
.................... #endif
.................... 
.................... #include "Utilities/entities.h"
.................... //entities.h
.................... 
.................... #ifndef ENTITIES_H
.................... #define ENTITIES_H
.................... 
.................... #include "vec2.h"
.................... 
.................... #define PLAYER_MAX_X    100
.................... #define PLAYER_MIN_X    80
.................... #define PLAYER_TOP_Y    0
.................... #define PLAYER_BOT_Y    50
.................... 
.................... #define ENEMY_TOP_Y     2
.................... #define ENEMY_BOT_Y     50
.................... #define ENEMY_STEP_X    13
.................... #define ENEMY_STEP_Y    5
.................... 
.................... #define BULLET_SPEED    12
.................... #define BULLET_MIN_X    5
.................... 
.................... typedef struct{
....................     Vec2 pos;
.................... } Player;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int vdir;               //-1 = up, 1 = down
....................     int reached_y_edge;    //1 for top, 0 for not reached, -1 for bottom
....................     int is_active;
.................... } Enemy;
.................... 
.................... typedef struct{
....................     Vec2 pos;
....................     int is_active;
.................... } Bullet;
.................... 
.................... int check_collisionBE(Bullet b, Enemy e);
.................... 
.................... #endif
.................... 
.................... #include "Utilities/vec2.h"
.................... #ifndef VEC2_H
.................... #define VEC2_H
.................... 
.................... typedef struct {
....................     int x;
....................     int y;
.................... } Vec2;
.................... 
.................... #endif
.................... 
.................... 
.................... #include "simple_scheduler.h"
.................... //simple_scheduler.h
.................... 
.................... #ifndef SIMPLE_SCHEDULER_H
.................... #define SIMPLE_SCHEDULER_H
.................... 
.................... typedef void (*task_fn_t)(void);  //function pointer for tasks
.................... 
.................... #define SCHED_MAX_TASKS 6
.................... 
.................... typedef struct{
....................     task_fn_t fn;
....................     unsigned char active; //1 for active, 0 for inactive
.................... } Task;
.................... 
.................... typedef struct{
....................     unsigned char count;
.................... } Semaphore;
.................... 
.................... typedef struct{
....................     unsigned char full;             //1 for full, 0 for empty
....................     unsigned char data[8];          //size can be changed
.................... } Mailbox;
.................... 
.................... //Scheduler functions
.................... void sched_init(void);
.................... int sched_add_task(task_fn_t fn);
.................... void sched_run_cycle(void);             //run one cycle
.................... void sched_run_forever(unsigned int cycle_delay_ms);
.................... 
.................... //Semaphore functions
.................... void sem_init(Semaphore *s, unsigned char init);
.................... unsigned char sem_trywait(Semaphore *s);
.................... void sem_signal(Semaphore *s);
.................... 
.................... //Mailbox functions
.................... void mbox_init(Mailbox *m);
.................... unsigned char mbox_send(Mailbox *m, int8 buf[], int8 size);
.................... unsigned char mbox_receive(Mailbox *m, int8 out[], int8 size);
.................... 
.................... #endif
.................... 
.................... 
.................... #define ENEMIES_PER_WAVE     6          //size of enemy wave
.................... #define ENEMY_X_LIMIT        75         // x limit for enemies that leads to game over
.................... 
.................... Enemy enemies[ENEMIES_PER_WAVE];
.................... Player p = {{80, 50}};
.................... Bullet b = {{0, 0}, 0};
.................... int score = 0;
.................... int last_score = 0;
.................... int wave_spawned = 0;
.................... int game_over_flag = 0;
.................... 
.................... Semaphore enemy_move_sem;
.................... int enemy_move_interval = 6;
.................... int frame_counter = 0;
.................... 
.................... Mailbox collision_mbox;
.................... 
.................... //spawns a wave of enemies with the positions set
.................... void spawn_enemy_wave() {
....................     Enemy new_wave[ENEMIES_PER_WAVE] = {
....................         {{5,  5}, 1, 0, 1 },
....................         {{5, 25}, 1, 0, 1 },
....................         {{5, 45}, 1, 0, 1 },
....................         {{30,  5}, 1, 0, 1 },
....................         {{30, 25}, 1, 0, 1 },
....................         {{30, 45}, 1, 0, 1 }   
....................     };
*
0072A:  MOVLW  05
0072C:  MOVLB  4
0072E:  MOVWF  xCC
00730:  MOVWF  xCD
00732:  MOVLW  01
00734:  MOVWF  xCE
00736:  CLRF   xCF
00738:  MOVWF  xD0
0073A:  MOVLW  05
0073C:  MOVWF  xD1
0073E:  MOVLW  19
00740:  MOVWF  xD2
00742:  MOVLW  01
00744:  MOVWF  xD3
00746:  CLRF   xD4
00748:  MOVWF  xD5
0074A:  MOVLW  05
0074C:  MOVWF  xD6
0074E:  MOVLW  2D
00750:  MOVWF  xD7
00752:  MOVLW  01
00754:  MOVWF  xD8
00756:  CLRF   xD9
00758:  MOVWF  xDA
0075A:  MOVLW  1E
0075C:  MOVWF  xDB
0075E:  MOVLW  05
00760:  MOVWF  xDC
00762:  MOVLW  01
00764:  MOVWF  xDD
00766:  CLRF   xDE
00768:  MOVWF  xDF
0076A:  MOVLW  1E
0076C:  MOVWF  xE0
0076E:  MOVLW  19
00770:  MOVWF  xE1
00772:  MOVLW  01
00774:  MOVWF  xE2
00776:  CLRF   xE3
00778:  MOVWF  xE4
0077A:  MOVLW  1E
0077C:  MOVWF  xE5
0077E:  MOVLW  2D
00780:  MOVWF  xE6
00782:  MOVLW  01
00784:  MOVWF  xE7
00786:  CLRF   xE8
00788:  MOVWF  xE9
.................... 
....................     for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
0078A:  CLRF   xEA
0078C:  MOVF   xEA,W
0078E:  SUBLW  05
00790:  BNC   07F6
....................         enemies[i] = new_wave[i];
00792:  MOVF   xEA,W
00794:  MULLW  05
00796:  MOVF   FF3,W
00798:  CLRF   03
0079A:  ADDLW  7F
0079C:  MOVWF  01
0079E:  MOVLW  04
007A0:  ADDWFC 03,F
007A2:  MOVFF  01,4EB
007A6:  MOVFF  03,FEA
007AA:  MOVF   xEA,W
007AC:  MULLW  05
007AE:  MOVF   FF3,W
007B0:  CLRF   03
007B2:  ADDLW  CC
007B4:  MOVWF  FE1
007B6:  MOVLW  04
007B8:  ADDWFC 03,W
007BA:  MOVWF  FE2
007BC:  MOVFF  01,FE9
007C0:  MOVLW  05
007C2:  MOVWF  01
007C4:  MOVFF  FE6,FEE
007C8:  DECFSZ 01,F
007CA:  BRA    07C4
....................         display_draw_enemy(enemies[i].pos);
007CC:  MOVF   xEA,W
007CE:  MULLW  05
007D0:  MOVF   FF3,W
007D2:  CLRF   xEC
007D4:  MOVWF  xEB
007D6:  MOVLW  7F
007D8:  ADDWF  xEB,W
007DA:  MOVWF  FE9
007DC:  MOVLW  04
007DE:  ADDWFC xEC,W
007E0:  MOVWF  FEA
007E2:  MOVFF  FEC,4F9
007E6:  MOVF   FED,F
007E8:  MOVFF  FEF,4F8
007EC:  MOVLB  0
007EE:  RCALL  0552
007F0:  MOVLB  4
007F2:  INCF   xEA,F
007F4:  BRA    078C
....................     }
007F6:  MOVLB  0
007F8:  RETURN 0
.................... }
.................... 
.................... void task_player(void){
....................     //task for all player controls
....................     display_clear_entity(p.pos, 8, 8);
*
00D10:  MOVFF  49E,4DD
00D14:  MOVFF  49D,4DC
00D18:  MOVLW  08
00D1A:  MOVLB  4
00D1C:  MOVWF  xDE
00D1E:  MOVWF  xDF
00D20:  MOVLB  0
00D22:  RCALL  0A96
....................     controller_update(&p.pos);
00D24:  MOVLW  04
00D26:  MOVLB  4
00D28:  MOVWF  xCA
00D2A:  MOVLW  9D
00D2C:  MOVWF  xC9
00D2E:  MOVLB  0
00D30:  BRA    0B16
....................     controller_shoot(p, &b);
00D32:  MOVFF  49E,4CA
00D36:  MOVFF  49D,4C9
00D3A:  MOVLW  04
00D3C:  MOVLB  4
00D3E:  MOVWF  xCC
00D40:  MOVLW  9F
00D42:  MOVWF  xCB
00D44:  MOVLB  0
00D46:  BRA    0C66
....................     p.pos = display_move_player(p.pos);
00D48:  MOVFF  49E,4CA
00D4C:  MOVFF  49D,4C9
00D50:  BRA    0CB8
00D52:  MOVFF  02,49E
00D56:  MOVFF  01,49D
00D5A:  RETURN 0
.................... }
.................... 
.................... void task_bullet(void){
....................     //task for bullet movement
....................     b = display_move_bullet(b);
*
00DAE:  MOVFF  4A1,4CB
00DB2:  MOVFF  4A0,4CA
00DB6:  MOVFF  49F,4C9
00DBA:  BRA    0D5C
00DBC:  MOVFF  03,4A1
00DC0:  MOVFF  02,4A0
00DC4:  MOVFF  01,49F
00DC8:  RETURN 0
.................... }
.................... 
.................... void task_collision(void){
....................     //task for checking collisions between enemies and bullets
....................     for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
*
00E6E:  MOVLB  4
00E70:  CLRF   xC9
00E72:  MOVF   xC9,W
00E74:  SUBLW  05
00E76:  BTFSS  FD8.0
00E78:  BRA    0F98
....................         if (check_collisionBE(b, enemies[i]) && b.is_active && enemies[i].is_active) {
00E7A:  MOVF   xC9,W
00E7C:  MULLW  05
00E7E:  MOVF   FF3,W
00E80:  CLRF   03
00E82:  ADDLW  7F
00E84:  MOVWF  FE9
00E86:  MOVLW  04
00E88:  ADDWFC 03,W
00E8A:  MOVWF  FEA
00E8C:  MOVF   FEE,F
00E8E:  MOVF   FEE,F
00E90:  MOVF   FEE,F
00E92:  MOVFF  FEC,4CF
00E96:  MOVF   FED,F
00E98:  MOVFF  FEF,4CE
00E9C:  MOVF   FED,F
00E9E:  MOVFF  FEF,4CD
00EA2:  MOVF   FED,F
00EA4:  MOVFF  FEF,4CC
00EA8:  MOVF   FED,F
00EAA:  MOVFF  FEF,4CF
00EAE:  MOVFF  4A1,4CE
00EB2:  MOVFF  4A0,4CD
00EB6:  MOVFF  49F,4CC
00EBA:  MOVFF  4CC,4D0
00EBE:  MOVFF  4CD,4D1
00EC2:  MOVFF  4CE,4D2
00EC6:  MOVFF  4CF,4D3
00ECA:  MOVLB  0
00ECC:  BRA    0DCA
00ECE:  MOVF   01,F
00ED0:  BZ    0F92
00ED2:  MOVLB  4
00ED4:  MOVF   xA1,F
00ED6:  BTFSS  FD8.2
00ED8:  BRA    0EDE
00EDA:  MOVLB  0
00EDC:  BRA    0F92
00EDE:  MOVF   xC9,W
00EE0:  MULLW  05
00EE2:  MOVF   FF3,W
00EE4:  CLRF   xCC
00EE6:  MOVWF  xCB
00EE8:  MOVLW  04
00EEA:  ADDWF  xCB,W
00EEC:  MOVWF  01
00EEE:  MOVLW  00
00EF0:  ADDWFC xCC,W
00EF2:  MOVWF  03
00EF4:  MOVF   01,W
00EF6:  ADDLW  7F
00EF8:  MOVWF  FE9
00EFA:  MOVLW  04
00EFC:  ADDWFC 03,W
00EFE:  MOVWF  FEA
00F00:  MOVF   FEF,F
00F02:  BTFSS  FD8.2
00F04:  BRA    0F0A
00F06:  MOVLB  0
00F08:  BRA    0F92
....................             int8 hit_flag[1] = {1};
00F0A:  MOVLW  01
00F0C:  MOVWF  xCA
.................... 
....................             mbox_send(&collision_mbox, hit_flag, 1);
00F0E:  MOVLW  04
00F10:  MOVWF  xCC
00F12:  MOVLW  A9
00F14:  MOVWF  xCB
00F16:  MOVLW  04
00F18:  MOVWF  xCE
00F1A:  MOVLW  CA
00F1C:  MOVWF  xCD
00F1E:  MOVLW  01
00F20:  MOVWF  xCF
00F22:  MOVLB  0
00F24:  BRA    0E0A
.................... 
....................             b.is_active = 0;
00F26:  MOVLB  4
00F28:  CLRF   xA1
....................             enemies[i].is_active = 0;
00F2A:  MOVF   xC9,W
00F2C:  MULLW  05
00F2E:  MOVF   FF3,W
00F30:  CLRF   xCC
00F32:  MOVWF  xCB
00F34:  MOVLW  04
00F36:  ADDWF  xCB,W
00F38:  MOVWF  01
00F3A:  MOVLW  00
00F3C:  ADDWFC xCC,W
00F3E:  MOVWF  03
00F40:  MOVF   01,W
00F42:  ADDLW  7F
00F44:  MOVWF  FE9
00F46:  MOVLW  04
00F48:  ADDWFC 03,W
00F4A:  MOVWF  FEA
00F4C:  CLRF   FEF
....................             display_clear_entity(enemies[i].pos, 8, 8);
00F4E:  MOVF   xC9,W
00F50:  MULLW  05
00F52:  MOVF   FF3,W
00F54:  CLRF   xCC
00F56:  MOVWF  xCB
00F58:  MOVLW  7F
00F5A:  ADDWF  xCB,W
00F5C:  MOVWF  FE9
00F5E:  MOVLW  04
00F60:  ADDWFC xCC,W
00F62:  MOVWF  FEA
00F64:  MOVFF  FEC,4DD
00F68:  MOVF   FED,F
00F6A:  MOVFF  FEF,4DC
00F6E:  MOVLW  08
00F70:  MOVWF  xDE
00F72:  MOVWF  xDF
00F74:  MOVLB  0
00F76:  RCALL  0A96
....................             display_clear_entity(b.pos, 8, 8);
00F78:  MOVFF  4A0,4DD
00F7C:  MOVFF  49F,4DC
00F80:  MOVLW  08
00F82:  MOVLB  4
00F84:  MOVWF  xDE
00F86:  MOVWF  xDF
00F88:  MOVLB  0
00F8A:  RCALL  0A96
....................             break;
00F8C:  MOVLB  4
00F8E:  BRA    0F98
00F90:  MOVLB  0
....................         }
00F92:  MOVLB  4
00F94:  INCF   xC9,F
00F96:  BRA    0E72
....................     }
.................... 
....................     //makes sure the bullet becomes inactive once it reaches left edge of screen
....................     if (b.is_active && b.pos.x <= BULLET_MIN_X){
00F98:  MOVF   xA1,F
00F9A:  BZ    0FB8
00F9C:  MOVF   x9F,W
00F9E:  SUBLW  05
00FA0:  BNC   0FB8
....................         b.is_active = 0;
00FA2:  CLRF   xA1
....................         display_clear_entity(b.pos, 8, 8);
00FA4:  MOVFF  4A0,4DD
00FA8:  MOVFF  49F,4DC
00FAC:  MOVLW  08
00FAE:  MOVWF  xDE
00FB0:  MOVWF  xDF
00FB2:  MOVLB  0
00FB4:  RCALL  0A96
00FB6:  MOVLB  4
....................     }
00FB8:  MOVLB  0
00FBA:  RETURN 0
.................... }
.................... 
.................... void task_display(void) {
....................     //task to update display and move enemies if needed
....................     display_update();
*
00FD6:  CALL   028E
....................     frame_counter++;
00FDA:  MOVLB  4
00FDC:  INCF   xA8,F
.................... 
....................     if (frame_counter % enemy_move_interval == 0){
00FDE:  MOVFF  4A8,4FD
00FE2:  MOVFF  4A7,4FE
00FE6:  MOVLB  0
00FE8:  RCALL  0886
00FEA:  MOVF   00,F
00FEC:  BNZ   0FFC
....................         sem_signal(&enemy_move_sem);
00FEE:  MOVLW  04
00FF0:  MOVLB  4
00FF2:  MOVWF  xCA
00FF4:  MOVLW  A6
00FF6:  MOVWF  xC9
00FF8:  MOVLB  0
00FFA:  BRA    0FBC
....................     }
00FFC:  RETURN 0
.................... }
.................... 
.................... void task_enemies(void) {
*
010CC:  MOVLB  4
010CE:  CLRF   xC9
....................     //task to handle all enemy spawning logic and movement
....................     int active_count = 0;
....................     for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
010D0:  CLRF   xCA
010D2:  MOVF   xCA,W
010D4:  SUBLW  05
010D6:  BNC   1104
....................         if (enemies[i].is_active) {
010D8:  MOVF   xCA,W
010DA:  MULLW  05
010DC:  MOVF   FF3,W
010DE:  CLRF   xCD
010E0:  MOVWF  xCC
010E2:  MOVLW  04
010E4:  ADDWF  xCC,W
010E6:  MOVWF  01
010E8:  MOVLW  00
010EA:  ADDWFC xCD,W
010EC:  MOVWF  03
010EE:  MOVF   01,W
010F0:  ADDLW  7F
010F2:  MOVWF  FE9
010F4:  MOVLW  04
010F6:  ADDWFC 03,W
010F8:  MOVWF  FEA
010FA:  MOVF   FEF,F
010FC:  BZ    1100
....................             active_count++;
010FE:  INCF   xC9,F
....................         }
01100:  INCF   xCA,F
01102:  BRA    10D2
....................     }
....................     if (active_count == 0 && !wave_spawned) {
01104:  MOVF   xC9,F
01106:  BNZ   1120
01108:  MOVF   xA4,F
0110A:  BNZ   1120
....................         if (enemy_move_interval > 1) {
0110C:  MOVF   xA7,W
0110E:  SUBLW  01
01110:  BC    1114
....................             enemy_move_interval--;
01112:  DECF   xA7,F
....................         }
....................         spawn_enemy_wave();
01114:  MOVLB  0
01116:  CALL   072A
....................         wave_spawned = 1;
0111A:  MOVLW  01
0111C:  MOVLB  4
0111E:  MOVWF  xA4
....................     }
....................     if (wave_spawned && active_count > 0) {
01120:  MOVF   xA4,F
01122:  BZ    112A
01124:  MOVF   xC9,F
01126:  BZ    112A
....................         wave_spawned = 0;
01128:  CLRF   xA4
....................     }
.................... 
....................     if (sem_trywait(&enemy_move_sem)) {
0112A:  MOVLW  04
0112C:  MOVWF  xCD
0112E:  MOVLW  A6
01130:  MOVWF  xCC
01132:  MOVLB  0
01134:  BRA    0FFE
01136:  MOVF   01,F
01138:  BZ    1202
....................         for (int i = 0; i < ENEMIES_PER_WAVE; i++) {
0113A:  MOVLB  4
0113C:  CLRF   xCB
0113E:  MOVF   xCB,W
01140:  SUBLW  05
01142:  BNC   1200
....................             if (enemies[i].is_active) {
01144:  MOVF   xCB,W
01146:  MULLW  05
01148:  MOVF   FF3,W
0114A:  CLRF   xCD
0114C:  MOVWF  xCC
0114E:  MOVLW  04
01150:  ADDWF  xCC,W
01152:  MOVWF  01
01154:  MOVLW  00
01156:  ADDWFC xCD,W
01158:  MOVWF  03
0115A:  MOVF   01,W
0115C:  ADDLW  7F
0115E:  MOVWF  FE9
01160:  MOVLW  04
01162:  ADDWFC 03,W
01164:  MOVWF  FEA
01166:  MOVF   FEF,F
01168:  BZ    11FC
....................                 enemies[i] = display_move_enemy(enemies[i]);
0116A:  MOVF   xCB,W
0116C:  MULLW  05
0116E:  MOVF   FF3,W
01170:  CLRF   03
01172:  ADDLW  7F
01174:  MOVWF  01
01176:  MOVLW  04
01178:  ADDWFC 03,F
0117A:  MOVFF  01,4CC
0117E:  MOVFF  03,4CD
01182:  MOVF   xCB,W
01184:  MULLW  05
01186:  MOVF   FF3,W
01188:  CLRF   03
0118A:  ADDLW  7F
0118C:  MOVWF  FE9
0118E:  MOVLW  04
01190:  ADDWFC 03,W
01192:  MOVWF  FEA
01194:  MOVF   FEE,F
01196:  MOVF   FEE,F
01198:  MOVF   FEE,F
0119A:  MOVFF  FEC,4D9
0119E:  MOVF   FED,F
011A0:  MOVFF  FEF,4D8
011A4:  MOVF   FED,F
011A6:  MOVFF  FEF,4D7
011AA:  MOVF   FED,F
011AC:  MOVFF  FEF,4D6
011B0:  MOVF   FED,F
011B2:  MOVFF  FEF,4D5
011B6:  MOVLB  0
011B8:  BRA    1034
011BA:  MOVFF  02,03
011BE:  MOVFF  01,FE1
011C2:  MOVFF  02,FE2
011C6:  MOVFF  4CD,FEA
011CA:  MOVFF  4CC,FE9
011CE:  MOVLW  05
011D0:  MOVWF  01
011D2:  MOVFF  FE6,FEE
011D6:  DECFSZ 01,F
011D8:  BRA    11D2
....................                 if (enemies[i].pos.x >= ENEMY_X_LIMIT) {
011DA:  MOVLB  4
011DC:  MOVF   xCB,W
011DE:  MULLW  05
011E0:  MOVF   FF3,W
011E2:  CLRF   xCD
011E4:  MOVWF  xCC
011E6:  MOVLW  7F
011E8:  ADDWF  xCC,W
011EA:  MOVWF  FE9
011EC:  MOVLW  04
011EE:  ADDWFC xCD,W
011F0:  MOVWF  FEA
011F2:  MOVF   FEF,W
011F4:  SUBLW  4A
011F6:  BC    11FC
....................                     game_over_flag = 1; //signal to stop scheduler
011F8:  MOVLW  01
011FA:  MOVWF  xA5
....................                 }
....................             }
011FC:  INCF   xCB,F
011FE:  BRA    113E
01200:  MOVLB  0
....................         }
....................     }
01202:  RETURN 0
.................... }
.................... 
.................... void task_score(void) {
....................     //task to handle score updates and drawing
....................     int8 hit_flag[1];
.................... 
....................     while (mbox_receive(&collision_mbox, hit_flag, 1)){
*
01288:  MOVLW  04
0128A:  MOVLB  4
0128C:  MOVWF  xCB
0128E:  MOVLW  A9
01290:  MOVWF  xCA
01292:  MOVLW  04
01294:  MOVWF  xCD
01296:  MOVLW  C9
01298:  MOVWF  xCC
0129A:  MOVLW  01
0129C:  MOVWF  xCE
0129E:  MOVLB  0
012A0:  BRA    1204
012A2:  MOVF   01,F
012A4:  BZ    12B2
....................         if (hit_flag[0] == 1) score++;
012A6:  MOVLB  4
012A8:  DECFSZ xC9,W
012AA:  BRA    12AE
012AC:  INCF   xA2,F
012AE:  MOVLB  0
012B0:  BRA    1288
....................     }
.................... 
....................     if (score != last_score) {
012B2:  MOVLB  4
012B4:  MOVF   xA3,W
012B6:  SUBWF  xA2,W
012B8:  BZ    12CC
....................         display_clear_score();
012BA:  MOVLB  0
012BC:  BRA    1268
....................         display_draw_score(score);
012BE:  MOVFF  4A2,4CA
012C2:  CALL   09A0
....................         last_score = score;
012C6:  MOVFF  4A2,4A3
012CA:  MOVLB  4
....................     }
012CC:  MOVLB  0
012CE:  RETURN 0
.................... }
.................... 
.................... void start_screen_loop() {
....................     //creates start screen and waits for user input to proceed
....................     display_clear();
*
006DE:  RCALL  01E4
....................     display_start_screen();
006E0:  BRA    0570
....................     display_update();
006E2:  RCALL  028E
.................... 
....................     while (TRUE) {
....................         controller_update_button_only();
006E4:  RCALL  069E
....................         if (is_button_just_pressed()) {
006E6:  RCALL  06D0
006E8:  MOVF   01,F
006EA:  BZ    06FA
....................             display_clear();
006EC:  RCALL  01E4
....................             delay_ms(100);
006EE:  MOVLW  64
006F0:  MOVLB  4
006F2:  MOVWF  xC8
006F4:  MOVLB  0
006F6:  RCALL  0012
....................             break;
006F8:  BRA    0706
....................         }
....................         delay_ms(100);
006FA:  MOVLW  64
006FC:  MOVLB  4
006FE:  MOVWF  xC8
00700:  MOVLB  0
00702:  RCALL  0012
00704:  BRA    06E4
....................     }
00706:  GOTO   170C (RETURN)
.................... }
.................... 
.................... void game_over_loop() {
*
0156C:  BRA    13CC
0156E:  MOVFF  01,4C4
....................     //creates game over screen and updates highscore if needed
....................     int hs = load_highscore();
....................     save_highscore(score, hs);
01572:  MOVFF  4A2,4C5
01576:  MOVFF  4C4,4C6
0157A:  BRA    1422
.................... 
....................     display_clear();
0157C:  CALL   0192
....................     display_gameover_screen(score, hs);
01580:  MOVFF  4A2,4C5
01584:  MOVFF  4C4,4C6
01588:  BRA    143A
....................     display_update();
0158A:  CALL   028E
.................... 
....................     while (TRUE) {
....................         controller_update_button_only();
0158E:  CALL   069E
....................         if (is_button_just_pressed()) {
01592:  CALL   06D0
01596:  MOVF   01,F
01598:  BZ    15AC
....................             display_clear();
0159A:  CALL   0192
....................             delay_ms(100);
0159E:  MOVLW  64
015A0:  MOVLB  4
015A2:  MOVWF  xC8
015A4:  MOVLB  0
015A6:  CALL   0012
....................             break;
015AA:  BRA    15BA
....................         }
....................         delay_ms(100);
015AC:  MOVLW  64
015AE:  MOVLB  4
015B0:  MOVWF  xC8
015B2:  MOVLB  0
015B4:  CALL   0012
015B8:  BRA    158E
....................     }
015BA:  GOTO   17DE (RETURN)
.................... }
.................... 
.................... void reset_globals(void){
....................     //resets all global variables to be able to restart the game
....................     score = 0;
*
0070A:  MOVLB  4
0070C:  CLRF   xA2
....................     last_score = 0;
0070E:  CLRF   xA3
....................     enemy_move_interval = 2;
00710:  MOVLW  02
00712:  MOVWF  xA7
....................     frame_counter = 0;
00714:  CLRF   xA8
....................     wave_spawned = 0;
00716:  CLRF   xA4
....................     game_over_flag = 0;
00718:  CLRF   xA5
....................     p.pos.x = 80; 
0071A:  MOVLW  50
0071C:  MOVWF  x9D
....................     p.pos.y = 50;
0071E:  MOVLW  32
00720:  MOVWF  x9E
....................     b.is_active = 0;
00722:  CLRF   xA1
00724:  MOVLB  0
00726:  GOTO   1710 (RETURN)
.................... }
.................... 
.................... void main() {
*
015BE:  CLRF   FF8
015C0:  BCF    FD0.7
015C2:  MOVLW  70
015C4:  MOVWF  FD3
015C6:  BCF    F9B.6
015C8:  BCF    F9B.7
015CA:  BSF    F94.3
015CC:  BSF    F94.4
015CE:  BCF    FCB.0
015D0:  BCF    FCB.1
015D2:  BCF    FCB.3
015D4:  MOVLW  27
015D6:  MOVWF  FC8
015D8:  MOVLW  28
015DA:  MOVWF  FC6
015DC:  BSF    FC7.7
015DE:  BCF    FC7.6
015E0:  MOVLB  4
015E2:  BCF    x04.0
015E4:  BCF    x04.1
015E6:  BCF    x04.2
015E8:  BCF    x04.3
015EA:  BRA    169E
015EC:  DATA 7A,04
015EE:  DATA 05,1F
015F0:  DATA 11,1F
015F2:  DATA 00,1F
015F4:  DATA 00,1D
015F6:  DATA 15,17
015F8:  DATA 15,15
015FA:  DATA 1F,07
015FC:  DATA 04,1F
015FE:  DATA 17,15
01600:  DATA 1D,1F
01602:  DATA 15,1D
01604:  DATA 01,01
01606:  DATA 1F,1F
01608:  DATA 15,1F
0160A:  DATA 17,15
0160C:  DATA 1F,61
0160E:  DATA 65,67
01610:  DATA 68,6D
01612:  DATA 6F,72
01614:  DATA 73,74
01616:  DATA 76,70
01618:  DATA 63,6C
0161A:  DATA 69,6B
0161C:  DATA 6E,64
0161E:  DATA 1E,05
01620:  DATA 1F,1F
01622:  DATA 15,15
01624:  DATA 0E,11
01626:  DATA 1D,1F
01628:  DATA 04,1F
0162A:  DATA 1F,06
0162C:  DATA 1F,0E
0162E:  DATA 11,0E
01630:  DATA 1F,05
01632:  DATA 1A,12
01634:  DATA 15,09
01636:  DATA 01,1F
01638:  DATA 01,07
0163A:  DATA 18,07
0163C:  DATA 1F,05
0163E:  DATA 02,0E
01640:  DATA 11,11
01642:  DATA 1F,10
01644:  DATA 10,00
01646:  DATA 1D,00
01648:  DATA 1F,04
0164A:  DATA 1B,1F
0164C:  DATA 01,1E
0164E:  DATA 1F,11
01650:  DATA 0E,70
01652:  DATA 8C,82
01654:  DATA 81,81
01656:  DATA 82,8C
01658:  DATA 70,18
0165A:  DATA 24,42
0165C:  DATA 81,42
0165E:  DATA 5A,24
01660:  DATA C3,00
01662:  DATA 00,00
01664:  DATA 7E,7E
01666:  DATA 00,00
01668:  DATA 00,02
0166A:  DATA 04,9D
0166C:  DATA 50,32
0166E:  DATA 05,C0
01670:  DATA 00,03
01672:  DATA 04,A2
01674:  DATA 00,00
01676:  DATA 00,02
01678:  DATA 04,A4
0167A:  DATA 00,00
0167C:  DATA 01,04
0167E:  DATA A5,00
01680:  DATA 02,04
01682:  DATA A7,06
01684:  DATA 00,02
01686:  DATA 04,A7
01688:  DATA 06,00
0168A:  DATA 12,44
0168C:  DATA B2,00
0168E:  DATA 05,4F
01690:  DATA 38,00
01692:  DATA 03,0F
01694:  DATA 77,00
01696:  DATA 00,00
01698:  DATA 01,0F
0169A:  DATA D3,70
0169C:  DATA 00,00
0169E:  MOVLW  00
016A0:  MOVWF  FF8
016A2:  MOVLW  15
016A4:  MOVWF  FF7
016A6:  MOVLW  EC
016A8:  MOVWF  FF6
016AA:  TBLRD*+
016AC:  MOVF   FF5,W
016AE:  MOVWF  00
016B0:  XORLW  00
016B2:  BZ    16DA
016B4:  TBLRD*+
016B6:  MOVF   FF5,W
016B8:  MOVWF  01
016BA:  BTFSC  FE8.7
016BC:  BRA    16C8
016BE:  ANDLW  3F
016C0:  MOVWF  FEA
016C2:  TBLRD*+
016C4:  MOVFF  FF5,FE9
016C8:  BTFSC  01.6
016CA:  TBLRD*+
016CC:  BTFSS  01.6
016CE:  TBLRD*+
016D0:  MOVFF  FF5,FEE
016D4:  DCFSNZ 00,F
016D6:  BRA    16AA
016D8:  BRA    16CC
016DA:  CLRF   FF8
....................     display_init();
016DC:  MOVLB  0
016DE:  GOTO   0292
....................     controller_init();
016E2:  GOTO   02CC
....................     sem_init(&enemy_move_sem, 0);
016E6:  MOVLW  04
016E8:  MOVLB  4
016EA:  MOVWF  xC5
016EC:  MOVLW  A6
016EE:  MOVWF  xC4
016F0:  CLRF   xC6
016F2:  MOVLB  0
016F4:  GOTO   02D2
....................     mbox_init(&collision_mbox);
016F8:  MOVLW  04
016FA:  MOVLB  4
016FC:  MOVWF  xC5
016FE:  MOVLW  A9
01700:  MOVWF  xC4
01702:  MOVLB  0
01704:  GOTO   02EE
.................... 
....................     while (TRUE) {
....................         start_screen_loop();
01708:  GOTO   06DE
....................         
....................         reset_globals();
0170C:  GOTO   070A
....................         display_clear();
01710:  CALL   0192
....................         spawn_enemy_wave();
01714:  CALL   072A
....................         display_draw_score(score);
01718:  MOVFF  4A2,4CA
0171C:  CALL   09A0
.................... 
....................         //setup scheduler tasks
....................         sched_init();
01720:  GOTO   09BA
....................         sched_add_task(task_bullet);
01724:  MOVLW  0D
01726:  MOVWF  03
01728:  MOVLW  AE
0172A:  MOVLB  4
0172C:  MOVWF  xC4
0172E:  MOVFF  03,4C5
01732:  MOVFF  03,4C7
01736:  MOVWF  xC6
01738:  MOVLB  0
0173A:  CALL   0A0E
....................         sched_add_task(task_collision);
0173E:  MOVLW  0E
01740:  MOVWF  03
01742:  MOVLW  6E
01744:  MOVLB  4
01746:  MOVWF  xC4
01748:  MOVFF  03,4C5
0174C:  MOVFF  03,4C7
01750:  MOVWF  xC6
01752:  MOVLB  0
01754:  CALL   0A0E
....................         sched_add_task(task_player);
01758:  MOVLW  0D
0175A:  MOVWF  03
0175C:  MOVLW  10
0175E:  MOVLB  4
01760:  MOVWF  xC4
01762:  MOVFF  03,4C5
01766:  MOVFF  03,4C7
0176A:  MOVWF  xC6
0176C:  MOVLB  0
0176E:  CALL   0A0E
....................         sched_add_task(task_enemies);
01772:  MOVLW  10
01774:  MOVWF  03
01776:  MOVLW  CC
01778:  MOVLB  4
0177A:  MOVWF  xC4
0177C:  MOVFF  03,4C5
01780:  MOVFF  03,4C7
01784:  MOVWF  xC6
01786:  MOVLB  0
01788:  CALL   0A0E
....................         sched_add_task(task_score);
0178C:  MOVLW  12
0178E:  MOVWF  03
01790:  MOVLW  88
01792:  MOVLB  4
01794:  MOVWF  xC4
01796:  MOVFF  03,4C5
0179A:  MOVFF  03,4C7
0179E:  MOVWF  xC6
017A0:  MOVLB  0
017A2:  CALL   0A0E
....................         sched_add_task(task_display);
017A6:  MOVLW  0F
017A8:  MOVWF  03
017AA:  MOVLW  D6
017AC:  MOVLB  4
017AE:  MOVWF  xC4
017B0:  MOVFF  03,4C5
017B4:  MOVFF  03,4C7
017B8:  MOVWF  xC6
017BA:  MOVLB  0
017BC:  CALL   0A0E
.................... 
....................         //keep running scheduler until player loses
....................         while (!game_over_flag) {
017C0:  MOVLB  4
017C2:  MOVF   xA5,F
017C4:  BNZ   17DA
....................             sched_run_cycle();
017C6:  MOVLB  0
017C8:  BRA    12D0
....................             delay_ms(100);
017CA:  MOVLW  64
017CC:  MOVLB  4
017CE:  MOVWF  xC8
017D0:  MOVLB  0
017D2:  CALL   0012
017D6:  BRA    17C0
017D8:  MOVLB  4
....................         }
.................... 
....................         game_over_loop();
017DA:  MOVLB  0
017DC:  BRA    156C
017DE:  BRA    1708
....................     }
.................... }
.................... 
017E0:  SLEEP 
.................... #include <18F46K22.h>
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
*
00004:  MOVFF  FEC,FFA
00008:  MOVF   FED,F
0000A:  MOVFF  FEF,FE8
0000E:  MOVWF  FF9
00010:  RETURN 0
.................... 
.................... #list
.................... 
.................... #use delay(clock=16M)
.................... #include "simple_scheduler.h"
.................... //simple_scheduler.h
.................... 
.................... #ifndef SIMPLE_SCHEDULER_H
.................... #define SIMPLE_SCHEDULER_H
.................... 
.................... typedef void (*task_fn_t)(void);  //function pointer for tasks
.................... 
.................... #define SCHED_MAX_TASKS 6
.................... 
.................... typedef struct{
....................     task_fn_t fn;
....................     unsigned char active; //1 for active, 0 for inactive
.................... } Task;
.................... 
.................... typedef struct{
....................     unsigned char count;
.................... } Semaphore;
.................... 
.................... typedef struct{
....................     unsigned char full;             //1 for full, 0 for empty
....................     unsigned char data[8];          //size can be changed
.................... } Mailbox;
.................... 
.................... //Scheduler functions
.................... void sched_init(void);
.................... int sched_add_task(task_fn_t fn);
.................... void sched_run_cycle(void);             //run one cycle
.................... void sched_run_forever(unsigned int cycle_delay_ms);
.................... 
.................... //Semaphore functions
.................... void sem_init(Semaphore *s, unsigned char init);
.................... unsigned char sem_trywait(Semaphore *s);
.................... void sem_signal(Semaphore *s);
.................... 
.................... //Mailbox functions
.................... void mbox_init(Mailbox *m);
.................... unsigned char mbox_send(Mailbox *m, int8 buf[], int8 size);
.................... unsigned char mbox_receive(Mailbox *m, int8 out[], int8 size);
.................... 
.................... #endif
.................... 
.................... 
.................... static Task task_list[SCHED_MAX_TASKS];
.................... 
.................... void sched_init(void){
....................     //initializes the scheduler
....................     unsigned char i;
.................... 
....................     for (i = 0; i < SCHED_MAX_TASKS; i++){
*
009BA:  MOVLB  4
009BC:  CLRF   xC4
009BE:  MOVF   xC4,W
009C0:  SUBLW  05
009C2:  BNC   0A08
....................         task_list[i].fn = 0;
009C4:  MOVF   xC4,W
009C6:  MULLW  03
009C8:  MOVF   FF3,W
009CA:  CLRF   xC6
009CC:  MOVWF  xC5
009CE:  MOVLW  B2
009D0:  ADDWF  xC5,W
009D2:  MOVWF  FE9
009D4:  MOVLW  04
009D6:  ADDWFC xC6,W
009D8:  MOVWF  FEA
009DA:  CLRF   FEC
009DC:  MOVF   FED,F
009DE:  CLRF   FEF
....................         task_list[i].active = 0;
009E0:  MOVF   xC4,W
009E2:  MULLW  03
009E4:  MOVF   FF3,W
009E6:  CLRF   xC6
009E8:  MOVWF  xC5
009EA:  MOVLW  02
009EC:  ADDWF  xC5,W
009EE:  MOVWF  01
009F0:  MOVLW  00
009F2:  ADDWFC xC6,W
009F4:  MOVWF  03
009F6:  MOVF   01,W
009F8:  ADDLW  B2
009FA:  MOVWF  FE9
009FC:  MOVLW  04
009FE:  ADDWFC 03,W
00A00:  MOVWF  FEA
00A02:  CLRF   FEF
00A04:  INCF   xC4,F
00A06:  BRA    09BE
....................     }
00A08:  MOVLB  0
00A0A:  GOTO   1724 (RETURN)
.................... }
.................... 
.................... int sched_add_task(task_fn_t fn){
....................     //adds task to scheduler list
....................     unsigned char i;
....................     for (i = 0; i < SCHED_MAX_TASKS; i++){
00A0E:  MOVLB  4
00A10:  CLRF   xC8
00A12:  MOVF   xC8,W
00A14:  SUBLW  05
00A16:  BNC   0A8E
....................         if (task_list[i].active == 0){
00A18:  MOVF   xC8,W
00A1A:  MULLW  03
00A1C:  MOVF   FF3,W
00A1E:  CLRF   xCA
00A20:  MOVWF  xC9
00A22:  MOVLW  02
00A24:  ADDWF  xC9,W
00A26:  MOVWF  01
00A28:  MOVLW  00
00A2A:  ADDWFC xCA,W
00A2C:  MOVWF  03
00A2E:  MOVF   01,W
00A30:  ADDLW  B2
00A32:  MOVWF  FE9
00A34:  MOVLW  04
00A36:  ADDWFC 03,W
00A38:  MOVWF  FEA
00A3A:  MOVF   FEF,F
00A3C:  BNZ   0A8A
....................             task_list[i].fn = fn;
00A3E:  MOVF   xC8,W
00A40:  MULLW  03
00A42:  MOVF   FF3,W
00A44:  CLRF   xCA
00A46:  MOVWF  xC9
00A48:  MOVLW  B2
00A4A:  ADDWF  xC9,W
00A4C:  MOVWF  FE9
00A4E:  MOVLW  04
00A50:  ADDWFC xCA,W
00A52:  MOVWF  FEA
00A54:  MOVFF  4C7,FEC
00A58:  MOVF   FED,F
00A5A:  MOVFF  4C6,FEF
....................             task_list[i].active = 1;
00A5E:  MOVF   xC8,W
00A60:  MULLW  03
00A62:  MOVF   FF3,W
00A64:  CLRF   xCA
00A66:  MOVWF  xC9
00A68:  MOVLW  02
00A6A:  ADDWF  xC9,W
00A6C:  MOVWF  01
00A6E:  MOVLW  00
00A70:  ADDWFC xCA,W
00A72:  MOVWF  03
00A74:  MOVF   01,W
00A76:  ADDLW  B2
00A78:  MOVWF  FE9
00A7A:  MOVLW  04
00A7C:  ADDWFC 03,W
00A7E:  MOVWF  FEA
00A80:  MOVLW  01
00A82:  MOVWF  FEF
....................             return i;
00A84:  MOVFF  4C8,01
00A88:  BRA    0A92
....................         }
00A8A:  INCF   xC8,F
00A8C:  BRA    0A12
....................     }
....................     return -1; //no space in the list
00A8E:  MOVLW  FF
00A90:  MOVWF  01
00A92:  MOVLB  0
00A94:  RETURN 0
.................... }
.................... 
.................... void sched_run_cycle(void){
....................     //runs a single scheduler cycle
....................     unsigned char i;
....................     for (i = 0; i < SCHED_MAX_TASKS; i++){
*
012D0:  MOVLB  4
012D2:  CLRF   xC4
012D4:  MOVF   xC4,W
012D6:  SUBLW  05
012D8:  BNC   1356
....................         if (task_list[i].active && task_list[i].fn != 0){
012DA:  MOVF   xC4,W
012DC:  MULLW  03
012DE:  MOVF   FF3,W
012E0:  CLRF   xC6
012E2:  MOVWF  xC5
012E4:  MOVLW  02
012E6:  ADDWF  xC5,W
012E8:  MOVWF  01
012EA:  MOVLW  00
012EC:  ADDWFC xC6,W
012EE:  MOVWF  03
012F0:  MOVF   01,W
012F2:  ADDLW  B2
012F4:  MOVWF  FE9
012F6:  MOVLW  04
012F8:  ADDWFC 03,W
012FA:  MOVWF  FEA
012FC:  MOVF   FEF,F
012FE:  BZ    1352
01300:  MOVF   xC4,W
01302:  MULLW  03
01304:  MOVF   FF3,W
01306:  CLRF   xC6
01308:  MOVWF  xC5
0130A:  MOVLW  B2
0130C:  ADDWF  xC5,W
0130E:  MOVWF  FE9
01310:  MOVLW  04
01312:  ADDWFC xC6,W
01314:  MOVWF  FEA
01316:  MOVFF  FEC,4C8
0131A:  MOVF   FED,F
0131C:  MOVFF  FEF,4C7
01320:  MOVF   xC7,F
01322:  BNZ   1328
01324:  MOVF   xC8,F
01326:  BZ    1352
....................             task_list[i].fn();
01328:  MOVF   xC4,W
0132A:  MULLW  03
0132C:  MOVF   FF3,W
0132E:  CLRF   xC6
01330:  MOVWF  xC5
01332:  MOVLW  B2
01334:  ADDWF  xC5,W
01336:  MOVWF  01
01338:  MOVLW  04
0133A:  ADDWFC xC6,W
0133C:  MOVWF  03
0133E:  MOVFF  01,4C7
01342:  MOVWF  xC8
01344:  MOVWF  FEA
01346:  MOVFF  01,FE9
0134A:  MOVLB  0
0134C:  CALL   0004
01350:  MOVLB  4
....................         }
01352:  INCF   xC4,F
01354:  BRA    12D4
....................     }
01356:  MOVLB  0
01358:  GOTO   17CA (RETURN)
.................... }
.................... 
.................... void sched_run_forever(unsigned int cycle_delay_ms){
....................     //runs the scheduler indefinitely
....................     while (1){
....................         sched_run_cycle();
....................         delay_ms(cycle_delay_ms);
....................     }
.................... }
.................... 
.................... void sem_init(Semaphore *s, unsigned char init){
....................     //initializes semaphore
....................     if (s != 0){
*
002D2:  MOVLB  4
002D4:  MOVF   xC4,F
002D6:  BNZ   02DC
002D8:  MOVF   xC5,F
002DA:  BZ    02E8
....................         s->count = init;
002DC:  MOVFF  4C4,FE9
002E0:  MOVFF  4C5,FEA
002E4:  MOVFF  4C6,FEF
....................     }
002E8:  MOVLB  0
002EA:  GOTO   16F8 (RETURN)
.................... }
.................... 
.................... unsigned char sem_trywait(Semaphore *s){    
....................     //checks if available but doesn't block
....................     if (s == 0) return 0;
*
00FFE:  MOVLB  4
01000:  MOVF   xCC,F
01002:  BNZ   100E
01004:  MOVF   xCD,F
01006:  BNZ   100E
01008:  MOVLW  00
0100A:  MOVWF  01
0100C:  BRA    102E
....................     if (s->count > 0){
0100E:  MOVFF  4CC,FE9
01012:  MOVFF  4CD,FEA
01016:  MOVF   FEF,F
01018:  BZ    102A
....................         s->count--;
0101A:  MOVFF  4CC,FE9
0101E:  MOVFF  4CD,FEA
01022:  DECF   FEF,F
....................         return 1;
01024:  MOVLW  01
01026:  MOVWF  01
01028:  BRA    102E
....................     }
....................     return 0;
0102A:  MOVLW  00
0102C:  MOVWF  01
0102E:  MOVLB  0
01030:  GOTO   1136 (RETURN)
.................... }
.................... 
.................... void sem_signal(Semaphore *s){
....................     //sends a signal to semaphore s 
....................     if (s != 0){
*
00FBC:  MOVLB  4
00FBE:  MOVF   xC9,F
00FC0:  BNZ   0FC6
00FC2:  MOVF   xCA,F
00FC4:  BZ    0FD0
....................         s->count++;
00FC6:  MOVFF  4C9,FE9
00FCA:  MOVFF  4CA,FEA
00FCE:  INCF   FEF,F
....................     }
00FD0:  MOVLB  0
00FD2:  GOTO   0FFC (RETURN)
.................... }
.................... 
.................... void mbox_init(Mailbox *m){
....................     //initializes mailbox
....................     unsigned char i;
....................     if (m != 0){
*
002EE:  MOVLB  4
002F0:  MOVF   xC4,F
002F2:  BNZ   02F8
002F4:  MOVF   xC5,F
002F6:  BZ    031E
....................         m->full = 0;
002F8:  MOVFF  4C4,FE9
002FC:  MOVFF  4C5,FEA
00300:  CLRF   FEF
....................         for (i = 0; i < sizeof(m->data); i++){
00302:  CLRF   xC6
00304:  MOVF   xC6,W
00306:  SUBLW  07
00308:  BNC   031E
....................             m->data[i] = 0;
0030A:  MOVLW  01
0030C:  ADDWF  xC6,W
0030E:  ADDWF  xC4,W
00310:  MOVWF  FE9
00312:  MOVLW  00
00314:  ADDWFC xC5,W
00316:  MOVWF  FEA
00318:  CLRF   FEF
0031A:  INCF   xC6,F
0031C:  BRA    0304
....................         }
....................     }
0031E:  MOVLB  0
00320:  GOTO   1708 (RETURN)
.................... }
.................... 
.................... unsigned char mbox_send(Mailbox *m, int8 buf[], int8 size) {
....................     //sends data to mailbox
....................     if (m->full || size > sizeof(m->data)) {
*
00E0A:  MOVLB  4
00E0C:  MOVFF  4CB,FE9
00E10:  MOVFF  4CC,FEA
00E14:  MOVF   FEF,F
00E16:  BNZ   0E1E
00E18:  MOVF   xCF,W
00E1A:  SUBLW  08
00E1C:  BC    0E24
....................         return 0; // fail
00E1E:  MOVLW  00
00E20:  MOVWF  01
00E22:  BRA    0E68
....................     }
....................     for (unsigned char i = 0; i < size; i++) {
00E24:  CLRF   xD0
00E26:  MOVF   xCF,W
00E28:  SUBWF  xD0,W
00E2A:  BC    0E5A
....................         m->data[i] = buf[i];
00E2C:  MOVLW  01
00E2E:  ADDWF  xD0,W
00E30:  ADDWF  xCB,W
00E32:  MOVWF  01
00E34:  MOVLW  00
00E36:  ADDWFC xCC,W
00E38:  MOVWF  03
00E3A:  MOVF   xD0,W
00E3C:  ADDWF  xCD,W
00E3E:  MOVWF  FE9
00E40:  MOVLW  00
00E42:  ADDWFC xCE,W
00E44:  MOVWF  FEA
00E46:  MOVFF  FEF,4D3
00E4A:  MOVFF  03,FEA
00E4E:  MOVFF  01,FE9
00E52:  MOVFF  4D3,FEF
00E56:  INCF   xD0,F
00E58:  BRA    0E26
....................     }
....................     m->full = 1;
00E5A:  MOVFF  4CB,FE9
00E5E:  MOVFF  4CC,FEA
00E62:  MOVLW  01
00E64:  MOVWF  FEF
....................     return 1; // success
00E66:  MOVWF  01
00E68:  MOVLB  0
00E6A:  GOTO   0F26 (RETURN)
.................... }
.................... 
.................... unsigned char mbox_receive(Mailbox *m, int8 out[], int8 size) {
....................     //receives data from mailbox
....................     if (!m->full || size > sizeof(m->data)) {
*
01204:  MOVLB  4
01206:  MOVFF  4CA,FE9
0120A:  MOVFF  4CB,FEA
0120E:  MOVF   FEF,F
01210:  BZ    1218
01212:  MOVF   xCE,W
01214:  SUBLW  08
01216:  BC    121E
....................         return 0; // fail
01218:  MOVLW  00
0121A:  MOVWF  01
0121C:  BRA    1262
....................     }
....................     for (unsigned char i = 0; i < size; i++) {
0121E:  CLRF   xCF
01220:  MOVF   xCE,W
01222:  SUBWF  xCF,W
01224:  BC    1254
....................         out[i] = m->data[i];
01226:  MOVF   xCF,W
01228:  ADDWF  xCC,W
0122A:  MOVWF  01
0122C:  MOVLW  00
0122E:  ADDWFC xCD,W
01230:  MOVWF  03
01232:  MOVLW  01
01234:  ADDWF  xCF,W
01236:  ADDWF  xCA,W
01238:  MOVWF  FE9
0123A:  MOVLW  00
0123C:  ADDWFC xCB,W
0123E:  MOVWF  FEA
01240:  MOVFF  FEF,4D2
01244:  MOVFF  03,FEA
01248:  MOVFF  01,FE9
0124C:  MOVFF  4D2,FEF
01250:  INCF   xCF,F
01252:  BRA    1220
....................     }
....................     m->full = 0;
01254:  MOVFF  4CA,FE9
01258:  MOVFF  4CB,FEA
0125C:  CLRF   FEF
....................     return 1; // success
0125E:  MOVLW  01
01260:  MOVWF  01
01262:  MOVLB  0
01264:  GOTO   12A2 (RETURN)
.................... }
.................... 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 P2BD2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
